<!DOCTYPE html>
<html>

<head>

	<style>
		* {
			padding: 0;
			margin: 0;
		}
		
		canvas {
			background: #CCCCCC;
			display: block;
			margin: 0 auto;
		}
	</style>

<title>Tanks</title>
</head>

<body>

	<canvas id="myCanvas" width="1300" height="630"></canvas>

	<body style="background-color:#CCCCCC;">

		<SCRIPT LANGUAGE="JavaScript">
			
			
			var canvas = document.getElementById("myCanvas");
			var ctx = canvas.getContext("2d");
			
			var maze = [[]];
			var player = [];
			var projectile = [[]];
			var baseProjectile = [{}];
			var powerUp = [];
			
			var powerUpCountdown = 0;
			var winCountdown = -2;
			var frezeCountdown = 0;
			
			
			var index1 = 0;
			var index2 = 0;
			var index3 = 0;
			
			var stop = false;
			var noIslands = true;
			
			var tankCorner = [[{}]];
			var intoWall = 0;
			var cornerSlope = 0;
			
			var movementVector = 0;
			
			
			
			var groupEdge = [[]];  //[[x, y, leftWall]]
			
			var tileGroup = [1,0,0]; //first one is the smaller of the other two
			
			
			var tileChance = 1.1; //inverse
			var wallChance = 2;
			var loopChance = 0.5;
			
			var modifierChance = 0.35; //percent
			
			var missileDrift = 0.2; //low is more
			
			var squareCenterLine = [[1,0,"leftWall"],[0,1,"topWall"],[1,1,"leftWall"],[1,1,"topWall"]];
			
			var playerAxis = [];
			
			var players = 4;
			var playerColor = ["Red","Lime","Blue","DarkOrange","Purple","Gold","Cyan","DeepPink","Green"];
			var controls = [["ArrowUp","ArrowDown","ArrowRight","ArrowLeft","/"],["w","s","d","a","q"],["y","h","j","g","t"],["p",";","'","l","o"]];
			var directionCode = ["forwards","backwards","right","left"];
			
			var tileSize = 50;
			var wallWidth = 2.5;
			
			var maze = {width:14,height:8};
			var border = {x:5,y:5};
			var mazeBorder = {x:0,y:0};
			var scoreArea = 80;
			var scale = 1;
			
			var tankScale = 3.6;
			var tankSpeed = 2.3;
			var backupSpeed = 0.6;
			
			var pickupBorder = 0.75;
			
			var laserUpdates = 80;
			var laserSpeed = 7;
			var laserbounce = false;
			
			var gattlingAmmo = 20;
			var gattlingSpeed = 3;
			
			var mineDelay = 30;
			var shrapnelFade = 30;
			
			
			
			function initializeArrays(){
				for(index1 = 0;index1 < 50;index1++){
					maze[index1] = [];
					for(index2 = 0;index2 < 50;index2++){
						maze[index1][index2] = {
							tile:0,
							leftWall:0,
							topWall:0,
							
							group:0
						}
					}
				}
				for(index1 = 0;index1 < players;index1++){
					player[index1] = {
						Xpos:0,
						Ypos:0,
						rotation:0,
						shooting:0,
						reload:0,
						powerUp:0,   //bullet, frag, laser, gattling, mine, missile, RC missile, death ray, magnet sphere thing, shrapnel
						modifier:0,  //nothing, swift, phase, triplet, colliding, frag
						dead:false,
						score:0,
						cantMove:false,
						cantShoot:false,
						
						ammo:0,//gattlingAmmo*gattlingSpeed,
						
						forwards:false,
						backwards:false,
						left:false,
						right:false,
						
						kills:0,
						deaths:0,
						wins:0
					}
				}
				for(index1 = 0;index1 < players;index1++){
					projectile[index1] = [];
					for(index2 = 0;index2 < 1000;index2++){
						projectile[index1][index2] = {
							Xpos:0,
							Ypos:0,
							Xspeed:0,
							Yspeed:0,
							speedVector:3,
							size:3,
							type:0,
							dead:true,
							
							timeLeft:0,
							
							phase:0,
							frag:false
						}
					}
				}
				for(index1 = 0;index1 < 100;index1++){
					powerUp[index1] = {
						Xpos:0,
						Ypos:0,
						rotation:0,
						type:0,      
						modifier:false,
						dead:true
					}
				}
				
				baseProjectile = [
					{
						type:0,
						size:2.5,
						speedVector:3,
						timeLeft:50*6
					},
					{
						type:1,
						size:4,
						speedVector:3,
						timeLeft:50*5
					},
					{
						type:2,
						size:1,
						speedVector:3,
						timeLeft:50*1.2,
						updates:laserUpdates,
						speed:laserSpeed,
						
						front:{x:0,y:0,xS:0,yS:0,move:laserUpdates},
						//front:{Xpos:0,Ypos:0,Xspeed:0,Yspeed:0,size:1,move:laserUpdates},
						back:{x:0,y:0}
						//back:{Xpos:0,Ypos:0}
					},
					{
						type:3,
						size:1.2,
						speedVector:3,
						timeLeft:50*3
					},
					{
						type:4,
						size:4,
						speedVector:-3,
						timeLeft:100000
					},
					{
						type:5,
						size:7,
						speedVector:3,
						timeLeft:50*6
					},
					{
						type:6,
						size:6,
						speedVector:3,
						rotation:0,
						timeLeft:50*10
					},
					{},
					{},
					{
						type:9,
						size:3,
						speedVector:4.5,
						corner:[0, Math.PI*2/3, Math.PI*4/3],
						rotation:0,
						rotationSpeed:0,
						timeLeft:50*5
					}
				];
			}
			
			
			function movePlayers(){
				for(index1 = 0;index1 < players;index1++){
					if(!player[index1].dead){
						player[index1].cantMove = false;
						player[index1].cantShoot = false;
						if(countProjectiles(index1, [6,7]) > 0){
							player[index1].cantMove = true;
						}
						for(index2 = 0;index2 < projectile[index1].length;index2++){
							if(!projectile[index1][index2].dead && projectile[index1][index2].type == 2 && projectile[index1][index2].timeLeft + projectile[index1][index2].updates/projectile[index1][index2].speed > baseProjectile[2].timeLeft){
								player[index1].cantMove = true;
							}
						}
						if((player[index1].powerUp == 0 && countProjectiles(index1, 0) >= 5) || countProjectiles(index1, [1,6,7,8]) > 0){
							player[index1].cantShoot = true;
						}
						
						if(!player[index1].cantMove){
							if(player[index1].left){
								player[index1].rotation += Math.PI/72 * tankSpeed;
							}
							if(player[index1].right){
								player[index1].rotation -= Math.PI/72 * tankSpeed;
							}
							if(player[index1].forwards){
								player[index1].Xpos += Math.sin(player[index1].rotation) * tankSpeed;
								player[index1].Ypos += Math.cos(player[index1].rotation) * tankSpeed;
							}
							if(player[index1].backwards){
								player[index1].Xpos -= Math.sin(player[index1].rotation) * tankSpeed * backupSpeed;
								player[index1].Ypos -= Math.cos(player[index1].rotation) * tankSpeed * backupSpeed;
							}

							tankCorner[index1] = [];
							for(index2 = 0;index2 < 4;index2++){
								for(index3 = 0;index3 < 4;index3++){
									getTankCorners(index1);
									if(maze[inTile(tankCorner[index1][index3].x - wallWidth)][inTile(tankCorner[index1][index3].y)].leftWall == 1 && maze[inTile(tankCorner[index1][index2].x - wallWidth)+1][inTile(tankCorner[index1][index2].y)].leftWall == 1 && inTile(tankCorner[index1][index2].x - wallWidth) == inTile(tankCorner[index1][index3].x - wallWidth) - 1){
										player[index1].Xpos += inTile(tankCorner[index1][index3].x)*tileSize - tankCorner[index1][index2].x + wallWidth;
									}
									getTankCorners(index1);
									if(maze[inTile(tankCorner[index1][index3].x + wallWidth)+1][inTile(tankCorner[index1][index3].y)].leftWall == 1 && maze[inTile(tankCorner[index1][index2].x + wallWidth)][inTile(tankCorner[index1][index2].y)].leftWall == 1 && inTile(tankCorner[index1][index2].x + wallWidth) == inTile(tankCorner[index1][index3].x + wallWidth) + 1){
										player[index1].Xpos += (inTile(tankCorner[index1][index3].x)+1)*tileSize - tankCorner[index1][index2].x - wallWidth;
									}
									getTankCorners(index1);
									if(maze[inTile(tankCorner[index1][index3].x)][inTile(tankCorner[index1][index3].y - wallWidth)].topWall == 1 && maze[inTile(tankCorner[index1][index2].x)][inTile(tankCorner[index1][index2].y - wallWidth)+1].topWall == 1 && inTile(tankCorner[index1][index2].y - wallWidth) == inTile(tankCorner[index1][index3].y - wallWidth) - 1){
										player[index1].Ypos += inTile(tankCorner[index1][index3].y)*tileSize - tankCorner[index1][index2].y + wallWidth;
									}
									getTankCorners(index1);
									if(maze[inTile(tankCorner[index1][index3].x)][inTile(tankCorner[index1][index3].y + wallWidth)+1].topWall == 1 && maze[inTile(tankCorner[index1][index2].x)][inTile(tankCorner[index1][index2].y + wallWidth)].topWall == 1 && inTile(tankCorner[index1][index2].y + wallWidth) == inTile(tankCorner[index1][index3].y + wallWidth) + 1){
										player[index1].Ypos += (inTile(tankCorner[index1][index3].y)+1)*tileSize - tankCorner[index1][index2].y - wallWidth;
									}
								}
							}/*
							for(index2 = 0;index2 < 4;index2++){
								for(index3 = 0;index3 < 4;index3++){
									getTankCorners(index1);
									if(isEquivalent(inTile(tankCorner[index1][index2].x - wallWidth,tankCorner[index1][index2].y) , inTile(player[index1].Xpos - tileSize,player[index1].Ypos)) && isEquivalent(inTile(tankCorner[index1][index3].x,tankCorner[index1][index3].y - wallWidth) , inTile(player[index1].Xpos,player[index1].Ypos - tileSize)) && (maze[inTile(tankCorner[index1][index2].x - wallWidth)][inTile(tankCorner[index1][index2].y)].topWall == 1 || maze[inTile(tankCorner[index1][index3].x)][inTile(tankCorner[index1][index3].y - wallWidth)].leftWall == 1)){
										if((inTile(player[index1].Ypos)*tileSize - (tankCorner[index1][index2].y - wallWidth))/(inTile(player[index1].Xpos)*tileSize - (tankCorner[index1][index2].x - wallWidth)) < (inTile(player[index1].Ypos)*tileSize - (tankCorner[index1][index3].y - wallWidth))/(inTile(player[index1].Xpos)*tileSize - (tankCorner[index1][index3].x - wallWidth))){
											cornerSlope = -(tankCorner[index1][index2].y - tankCorner[index1][index3].y)/(tankCorner[index1][index2].x - tankCorner[index1][index3].x);
											tankCorner[index1][index3].x = (cornerSlope*(inTile(player[index1].Xpos)*tileSize - wallWidth) + ((tankCorner[index1][index2].x - wallWidth)/cornerSlope) - (inTile(player[index1].Ypos)*tileSize - wallWidth) + (tankCorner[index1][index2].y - wallWidth))*cornerSlope/(cornerSlope*cornerSlope + 1);
											tankCorner[index1][index3].y = cornerSlope*(tankCorner[index1][index3].x - (inTile(player[index1].Xpos)*tileSize - wallWidth)) + (inTile(player[index1].Ypos)*tileSize - wallWidth);

											//player[index1].Ypos += tankCorner[index1][index3].x - tankCorner[index1][index2].x;
											//player[index1].Xpos -= tankCorner[index1][index3].y - tankCorner[index1][index2].y;
										}
									}
								}
							}*/
						}
						else{
							for(index2 = 0;index2 < projectile[index1].length;index2++){
								if(!projectile[index1][index2].dead && projectile[index1][index2].type == 6){
									if(player[index1].left){
										projectile[index1][index2].rotation += Math.PI/20;
									}
									if(player[index1].right){
										projectile[index1][index2].rotation -= Math.PI/20;
									}
								}
							}
						}
						
						if(player[index1].shooting == 2){
							if(!player[index1].cantShoot){

								if(player[index1].powerUp != 3) player[index1].shooting = 1;
								else{
									if(player[index1].reload == 0){
										player[index1].reload = player[index1].modifier == 3 ? 1:3;
										player[index1].ammo--;
									}
									player[index1].reload--;
								}
								if(player[index1].powerUp == 4) player[index1].ammo--;

								if(!(player[index1].powerUp == 3 && player[index1].reload > 0)){
									shoot(index1, player[index1].powerUp, player[index1].modifier == 3 && player[index1].powerUp > 0 && player[index1].powerUp != 3 ? 3 : 1, player[index1].powerUp == 3 ? player[index1].modifier == 3 ? 0.6:0.3:(player[index1].powerUp == 4 ? 0.7:0.1), player[index1].powerUp == 3, {speed:player[index1].modifier == 1 && player[index1].powerUp > 0 ? 1.5 : 1,phase:player[index1].modifier == 2 && player[index1].powerUp > 0 ? Math.min(50*2, baseProjectile[player[index1].powerUp].timeLeft/2) : 0});
									if(player[index1].powerUp > 0 && player[index1].powerUp != 3 && player[index1].powerUp != 4){
										player[index1].powerUp = 0;
										player[index1].modifier = 0;
									}
								}
							}
							else{
								for(index2 = 0;index2 < projectile[index1].length;index2++){
									if(!projectile[index1][index2].dead && projectile[index1][index2].type == 1 && projectile[index1][index2].timeLeft < baseProjectile[1].timeLeft){
										onKill(index1, index2);
										projectile[index1][index2].dead = true;
										player[index1].shooting = 1;
									}
								}
							}
						}
						if((player[index1].powerUp == 3 || player[index1].powerUp == 4) && player[index1].ammo == 0){
							player[index1].powerUp = 0;
							player[index1].modifier = 0;
							player[index1].shooting = 1;
						}
						
						for(index2 = 0;index2 < powerUp.length;index2++){
							if(!powerUp[index2].dead && distance(player[index1].Xpos, player[index1].Ypos, powerUp[index2].Xpos, powerUp[index2].Ypos) < 20){
								pickUp(index1, index2);
							}
						}
					}
				}
			}
			function getTankCorners(tank){
				tankCorner[tank][0] = {x:player[tank].Xpos + Math.sin(-Math.PI/2 + Math.atan( 7/5) + player[tank].rotation)*tankScale*Math.sqrt(13), y:player[tank].Ypos + Math.cos(-Math.PI/2 + Math.atan( 7/5) + player[tank].rotation)*tankScale*Math.sqrt(13)};
				tankCorner[tank][1] = {x:player[tank].Xpos + Math.sin( Math.PI/2 - Math.atan( 7/5) + player[tank].rotation)*tankScale*Math.sqrt(13), y:player[tank].Ypos + Math.cos( Math.PI/2 - Math.atan( 7/5) + player[tank].rotation)*tankScale*Math.sqrt(13)};
				tankCorner[tank][2] = {x:player[tank].Xpos + Math.sin( Math.PI/2 - Math.atan(-7/5) + player[tank].rotation)*tankScale*Math.sqrt(13), y:player[tank].Ypos + Math.cos( Math.PI/2 - Math.atan(-7/5) + player[tank].rotation)*tankScale*Math.sqrt(13)};
				tankCorner[tank][3] = {x:player[tank].Xpos + Math.sin(-Math.PI/2 + Math.atan(-7/5) + player[tank].rotation)*tankScale*Math.sqrt(13), y:player[tank].Ypos + Math.cos(-Math.PI/2 + Math.atan(-7/5) + player[tank].rotation)*tankScale*Math.sqrt(13)};
			}
			function moveProjectiles(){
				var wallPush = 0;
				for(index1 = 0;index1 < players;index1++){
					for(index2 = 0;index2 < projectile[index1].length;index2++){
						if(!projectile[index1][index2].dead){
							if(projectile[index1][index2].type != 2){
								
								//if(projectile[index1][index2].timeLeft != baseProjectile[projectile[index1][index2].type].timeLeft){
									if(projectile[index1][index2].type == 9) projectile[index1][index2].rotation += projectile[index1][index2].rotationSpeed;
									if(projectile[index1][index2].type == 6){
										projectile[index1][index2].Xspeed += Math.sin(projectile[index1][index2].rotation)*projectile[index1][index2].speedVector * missileDrift;
										projectile[index1][index2].Yspeed += Math.cos(projectile[index1][index2].rotation)*projectile[index1][index2].speedVector * missileDrift;
										movementVector = projectile[index1][index2].speedVector / distance(0, 0, projectile[index1][index2].Xspeed, projectile[index1][index2].Yspeed);
										projectile[index1][index2].Xspeed *= movementVector;
										projectile[index1][index2].Yspeed *= movementVector;
									}
									projectile[index1][index2].Xpos += projectile[index1][index2].Xspeed;
									projectile[index1][index2].Ypos += projectile[index1][index2].Yspeed;
								//}
								
								wallBounce(projectile[index1][index2]);
								/*
								if(projectile[index1][index2].phase <= 0 && inTile(projectile[index1][index2].Xpos - wallWidth - projectile[index1][index2].size) != inTile(projectile[index1][index2].Xpos) && maze[inTile(projectile[index1][index2].Xpos)][inTile(projectile[index1][index2].Ypos)].leftWall == 1
								  || maze[inTile(projectile[index1][index2].Xpos - wallWidth - projectile[index1][index2].size)][inTile(projectile[index1][index2].Ypos)].tile == 1){
									projectile[index1][index2].Xpos = inTile(projectile[index1][index2].Xpos)*tileSize + wallWidth + projectile[index1][index2].size;
									projectile[index1][index2].Xspeed *= -1;
									if(projectile[index1][index2].type == 9){
										projectile[index1][index2].timeLeft = Math.min(projectile[index1][index2].timeLeft, shrapnelFade);
										projectile[index1][index2].Xspeed = 0;
										projectile[index1][index2].Yspeed = 0;
										projectile[index1][index2].rotationSpeed = 0;
									}
									if(projectile[index1][index2].type == 6)projectile[index1][index2].rotation *= -1;
								}
								if(projectile[index1][index2].phase <= 0 && inTile(projectile[index1][index2].Xpos + wallWidth + projectile[index1][index2].size) != inTile(projectile[index1][index2].Xpos) && maze[inTile(projectile[index1][index2].Xpos)+1][inTile(projectile[index1][index2].Ypos)].leftWall == 1
								  || maze[inTile(projectile[index1][index2].Xpos + wallWidth + projectile[index1][index2].size)][inTile(projectile[index1][index2].Ypos)].tile == 1){
									projectile[index1][index2].Xpos = (inTile(projectile[index1][index2].Xpos)+1)*tileSize - wallWidth - projectile[index1][index2].size;
									projectile[index1][index2].Xspeed *= -1;
									if(projectile[index1][index2].type == 9){
										projectile[index1][index2].timeLeft = Math.min(projectile[index1][index2].timeLeft, shrapnelFade);
										projectile[index1][index2].Xspeed = 0;
										projectile[index1][index2].Yspeed = 0;
										projectile[index1][index2].rotationSpeed = 0;
									}
									if(projectile[index1][index2].type == 6)projectile[index1][index2].rotation *= -1;
								}
								if(projectile[index1][index2].phase <= 0 && inTile(projectile[index1][index2].Ypos - wallWidth - projectile[index1][index2].size) != inTile(projectile[index1][index2].Ypos) && maze[inTile(projectile[index1][index2].Xpos)][inTile(projectile[index1][index2].Ypos)].topWall == 1
								  || maze[inTile(projectile[index1][index2].Xpos)][inTile(projectile[index1][index2].Ypos - wallWidth - projectile[index1][index2].size)].tile == 1){
									projectile[index1][index2].Ypos = inTile(projectile[index1][index2].Ypos)*tileSize + wallWidth + projectile[index1][index2].size;
									projectile[index1][index2].Yspeed *= -1;
									if(projectile[index1][index2].type == 9){
										projectile[index1][index2].timeLeft = Math.min(projectile[index1][index2].timeLeft, shrapnelFade);
										projectile[index1][index2].Xspeed = 0;
										projectile[index1][index2].Yspeed = 0;
										projectile[index1][index2].rotationSpeed = 0;
									}
									if(projectile[index1][index2].type == 6)projectile[index1][index2].rotation = Math.PI - projectile[index1][index2].rotation;
								}
								if(projectile[index1][index2].phase <= 0 && inTile(projectile[index1][index2].Ypos + wallWidth + projectile[index1][index2].size) != inTile(projectile[index1][index2].Ypos) && maze[inTile(projectile[index1][index2].Xpos)][inTile(projectile[index1][index2].Ypos)+1].topWall == 1
								  || maze[inTile(projectile[index1][index2].Xpos)][inTile(projectile[index1][index2].Ypos + wallWidth + projectile[index1][index2].size)].tile == 1){
									projectile[index1][index2].Ypos = (inTile(projectile[index1][index2].Ypos)+1)*tileSize - wallWidth - projectile[index1][index2].size;
									projectile[index1][index2].Yspeed *= -1;
									if(projectile[index1][index2].type == 9){
										projectile[index1][index2].timeLeft = Math.min(projectile[index1][index2].timeLeft, shrapnelFade);
										projectile[index1][index2].Xspeed = 0;
										projectile[index1][index2].Yspeed = 0;
										projectile[index1][index2].rotationSpeed = 0;
									}
									if(projectile[index1][index2].type == 6)projectile[index1][index2].rotation = Math.PI - projectile[index1][index2].rotation;
								}*/
								
								if(projectile[index1][index2].phase <= 0 && maze[inTile(projectile[index1][index2].Xpos)][inTile(projectile[index1][index2].Ypos)].topWall + maze[inTile(projectile[index1][index2].Xpos)][inTile(projectile[index1][index2].Ypos)].leftWall + maze[inTile(projectile[index1][index2].Xpos)-1][inTile(projectile[index1][index2].Ypos)].topWall + maze[inTile(projectile[index1][index2].Xpos)][inTile(projectile[index1][index2].Ypos)-1].leftWall > 0
								   && inTile(projectile[index1][index2].Xpos - wallWidth - projectile[index1][index2].size) != inTile(projectile[index1][index2].Xpos) && projectile[index1][index2].Ypos > inTile(projectile[index1][index2].Ypos)*tileSize - wallWidth && projectile[index1][index2].Ypos < inTile(projectile[index1][index2].Ypos)*tileSize + wallWidth
								  /*|| maze[inTile(projectile[index1][index2].Xpos - wallWidth - projectile[index1][index2].size)][inTile(projectile[index1][index2].Ypos - wallWidth - projectile[index1][index2].size)].tile  +  maze[inTile(projectile[index1][index2].Xpos - wallWidth - projectile[index1][index2].size)][inTile(projectile[index1][index2].Ypos + wallWidth + projectile[index1][index2].size)].tile > 0*/){
									projectile[index1][index2].Xpos = inTile(projectile[index1][index2].Xpos)*tileSize + wallWidth + projectile[index1][index2].size;
									if(projectile[index1][index2].type == 9){
										projectile[index1][index2].timeLeft = Math.min(projectile[index1][index2].timeLeft, shrapnelFade);
										projectile[index1][index2].Xspeed = 0;
										projectile[index1][index2].Yspeed = 0;
										projectile[index1][index2].rotationSpeed = 0;
									}
									else{
										projectile[index1][index2].Xspeed *= -1;
									}
									//if(projectile[index1][index2].type == 6)projectile[index1][index2].rotation *= -1;
								}
								if(projectile[index1][index2].phase <= 0 && maze[inTile(projectile[index1][index2].Xpos)+1][inTile(projectile[index1][index2].Ypos)].topWall + maze[inTile(projectile[index1][index2].Xpos)+1][inTile(projectile[index1][index2].Ypos)].leftWall + maze[inTile(projectile[index1][index2].Xpos)][inTile(projectile[index1][index2].Ypos)].topWall + maze[inTile(projectile[index1][index2].Xpos)+1][inTile(projectile[index1][index2].Ypos)-1].leftWall > 0
								   && inTile(projectile[index1][index2].Xpos + wallWidth + projectile[index1][index2].size) != inTile(projectile[index1][index2].Xpos) && projectile[index1][index2].Ypos > inTile(projectile[index1][index2].Ypos)*tileSize - wallWidth && projectile[index1][index2].Ypos < inTile(projectile[index1][index2].Ypos)*tileSize + wallWidth){
									if(projectile[index1][index2].type == 9){
										projectile[index1][index2].timeLeft = Math.min(projectile[index1][index2].timeLeft, shrapnelFade);
										projectile[index1][index2].Xspeed = 0;
										projectile[index1][index2].Yspeed = 0;
										projectile[index1][index2].rotationSpeed = 0;
									}
									else{
										projectile[index1][index2].Xpos = (inTile(projectile[index1][index2].Xpos)+1)*tileSize - wallWidth - projectile[index1][index2].size;
										projectile[index1][index2].Xspeed *= -1;
									}
									//if(projectile[index1][index2].type == 6)projectile[index1][index2].rotation *= -1;
								}
								if(projectile[index1][index2].phase <= 0 && maze[inTile(projectile[index1][index2].Xpos)][inTile(projectile[index1][index2].Ypos)].topWall + maze[inTile(projectile[index1][index2].Xpos)][inTile(projectile[index1][index2].Ypos)].leftWall + maze[inTile(projectile[index1][index2].Xpos)-1][inTile(projectile[index1][index2].Ypos)].topWall + maze[inTile(projectile[index1][index2].Xpos)][inTile(projectile[index1][index2].Ypos)-1].leftWall > 0
								   && inTile(projectile[index1][index2].Ypos - wallWidth - projectile[index1][index2].size) != inTile(projectile[index1][index2].Ypos) && projectile[index1][index2].Xpos > inTile(projectile[index1][index2].Xpos)*tileSize - wallWidth && projectile[index1][index2].Xpos < inTile(projectile[index1][index2].Xpos)*tileSize + wallWidth){
									if(projectile[index1][index2].type == 9){
										projectile[index1][index2].timeLeft = Math.min(projectile[index1][index2].timeLeft, shrapnelFade);
										projectile[index1][index2].Xspeed = 0;
										projectile[index1][index2].Yspeed = 0;
										projectile[index1][index2].rotationSpeed = 0;
									}
									else{
										projectile[index1][index2].Ypos = inTile(projectile[index1][index2].Ypos)*tileSize + wallWidth + projectile[index1][index2].size;
										projectile[index1][index2].Yspeed *= -1;
									}
									//if(projectile[index1][index2].type == 6)projectile[index1][index2].rotation = Math.PI - projectile[index1][index2].rotation;
								}
								if(projectile[index1][index2].phase <= 0 && maze[inTile(projectile[index1][index2].Xpos)][inTile(projectile[index1][index2].Ypos)+1].topWall + maze[inTile(projectile[index1][index2].Xpos)][inTile(projectile[index1][index2].Ypos)+1].leftWall + maze[inTile(projectile[index1][index2].Xpos)-1][inTile(projectile[index1][index2].Ypos)+1].topWall + maze[inTile(projectile[index1][index2].Xpos)][inTile(projectile[index1][index2].Ypos)].leftWall > 0
								   && inTile(projectile[index1][index2].Ypos + wallWidth + projectile[index1][index2].size) != inTile(projectile[index1][index2].Ypos) && projectile[index1][index2].Xpos > inTile(projectile[index1][index2].Xpos)*tileSize - wallWidth && projectile[index1][index2].Xpos < inTile(projectile[index1][index2].Xpos)*tileSize + wallWidth){
									if(projectile[index1][index2].type == 9){
										projectile[index1][index2].timeLeft = Math.min(projectile[index1][index2].timeLeft, shrapnelFade);
										projectile[index1][index2].Xspeed = 0;
										projectile[index1][index2].Yspeed = 0;
										projectile[index1][index2].rotationSpeed = 0;
									}
									else{
										projectile[index1][index2].Ypos = (inTile(projectile[index1][index2].Ypos)+1)*tileSize - wallWidth - projectile[index1][index2].size;
										projectile[index1][index2].Yspeed *= -1;
									}
									//if(projectile[index1][index2].type == 6)projectile[index1][index2].rotation = Math.PI - projectile[index1][index2].rotation;
								}

								if(projectile[index1][index2].phase <= 0 && maze[inTile(projectile[index1][index2].Xpos)][inTile(projectile[index1][index2].Ypos)].topWall + maze[inTile(projectile[index1][index2].Xpos)][inTile(projectile[index1][index2].Ypos)].leftWall + maze[inTile(projectile[index1][index2].Xpos)-1][inTile(projectile[index1][index2].Ypos)].topWall + maze[inTile(projectile[index1][index2].Xpos)][inTile(projectile[index1][index2].Ypos)-1].leftWall > 0){
									movementVector = distance(inTile(projectile[index1][index2].Xpos)*tileSize + wallWidth, inTile(projectile[index1][index2].Ypos)*tileSize + wallWidth, projectile[index1][index2].Xpos, projectile[index1][index2].Ypos);
									if(movementVector < projectile[index1][index2].size){
										if(projectile[index1][index2].type == 9){
											projectile[index1][index2].timeLeft = Math.min(projectile[index1][index2].timeLeft, shrapnelFade);
											projectile[index1][index2].Xspeed = 0;
											projectile[index1][index2].Yspeed = 0;
											projectile[index1][index2].rotationSpeed = 0;
										}
										else{
											projectile[index1][index2].Xpos = inTile(projectile[index1][index2].Xpos)*tileSize + wallWidth + (projectile[index1][index2].Xpos - (inTile(projectile[index1][index2].Xpos)*tileSize + wallWidth))*projectile[index1][index2].size/movementVector;
											projectile[index1][index2].Ypos = inTile(projectile[index1][index2].Ypos)*tileSize + wallWidth + (projectile[index1][index2].Ypos - (inTile(projectile[index1][index2].Ypos)*tileSize + wallWidth))*projectile[index1][index2].size/movementVector;
											projectile[index1][index2].Xspeed = Math.abs(projectile[index1][index2].Xspeed);
											projectile[index1][index2].Yspeed = Math.abs(projectile[index1][index2].Yspeed);
										}
										if(projectile[index1][index2].type == 6)projectile[index1][index2].rotation = projectile[index1][index2].rotation % (Math.PI/2);
									}
								}
								if(projectile[index1][index2].phase <= 0 && maze[inTile(projectile[index1][index2].Xpos)+1][inTile(projectile[index1][index2].Ypos)].topWall + maze[inTile(projectile[index1][index2].Xpos)+1][inTile(projectile[index1][index2].Ypos)].leftWall + maze[inTile(projectile[index1][index2].Xpos)][inTile(projectile[index1][index2].Ypos)].topWall + maze[inTile(projectile[index1][index2].Xpos)+1][inTile(projectile[index1][index2].Ypos)-1].leftWall > 0){
									movementVector = distance((inTile(projectile[index1][index2].Xpos)+1)*tileSize - wallWidth, inTile(projectile[index1][index2].Ypos)*tileSize + wallWidth, projectile[index1][index2].Xpos, projectile[index1][index2].Ypos);
									if(movementVector < projectile[index1][index2].size){
										if(projectile[index1][index2].type == 9){
											projectile[index1][index2].timeLeft = Math.min(projectile[index1][index2].timeLeft, shrapnelFade);
											projectile[index1][index2].Xspeed = 0;
											projectile[index1][index2].Yspeed = 0;
											projectile[index1][index2].rotationSpeed = 0;
										}
										else{
											projectile[index1][index2].Xpos = (inTile(projectile[index1][index2].Xpos)+1)*tileSize - wallWidth + (projectile[index1][index2].Xpos - ((inTile(projectile[index1][index2].Xpos)+1)*tileSize - wallWidth))*projectile[index1][index2].size/movementVector;
											projectile[index1][index2].Ypos = inTile(projectile[index1][index2].Ypos)*tileSize + wallWidth + (projectile[index1][index2].Ypos - (inTile(projectile[index1][index2].Ypos)*tileSize + wallWidth))*projectile[index1][index2].size/movementVector;
											projectile[index1][index2].Xspeed = -Math.abs(projectile[index1][index2].Xspeed);
											projectile[index1][index2].Yspeed = Math.abs(projectile[index1][index2].Yspeed);
										}
										if(projectile[index1][index2].type == 6)projectile[index1][index2].rotation = projectile[index1][index2].rotation % (Math.PI/2) + Math.PI*3/2;
									}
								}
								if(projectile[index1][index2].phase <= 0 && maze[inTile(projectile[index1][index2].Xpos)][inTile(projectile[index1][index2].Ypos)+1].topWall + maze[inTile(projectile[index1][index2].Xpos)][inTile(projectile[index1][index2].Ypos)+1].leftWall + maze[inTile(projectile[index1][index2].Xpos)-1][inTile(projectile[index1][index2].Ypos)+1].topWall + maze[inTile(projectile[index1][index2].Xpos)][inTile(projectile[index1][index2].Ypos)].leftWall > 0){
									movementVector = distance(inTile(projectile[index1][index2].Xpos)*tileSize + wallWidth, (inTile(projectile[index1][index2].Ypos)+1)*tileSize - wallWidth, projectile[index1][index2].Xpos, projectile[index1][index2].Ypos);
									if(movementVector < projectile[index1][index2].size){
										if(projectile[index1][index2].type == 9){
											projectile[index1][index2].timeLeft = Math.min(projectile[index1][index2].timeLeft, shrapnelFade);
											projectile[index1][index2].Xspeed = 0;
											projectile[index1][index2].Yspeed = 0;
											projectile[index1][index2].rotationSpeed = 0;
										}
										else{
											projectile[index1][index2].Xpos = inTile(projectile[index1][index2].Xpos)*tileSize + wallWidth + (projectile[index1][index2].Xpos - (inTile(projectile[index1][index2].Xpos)*tileSize + wallWidth))*projectile[index1][index2].size/movementVector;
											projectile[index1][index2].Ypos = (inTile(projectile[index1][index2].Ypos)+1)*tileSize - wallWidth + (projectile[index1][index2].Ypos - ((inTile(projectile[index1][index2].Ypos)+1)*tileSize - wallWidth))*projectile[index1][index2].size/movementVector;
											projectile[index1][index2].Xspeed = Math.abs(projectile[index1][index2].Xspeed);
											projectile[index1][index2].Yspeed = -Math.abs(projectile[index1][index2].Yspeed);
										}
										//if(projectile[index1][index2].type == 6)projectile[index1][index2].rotation = -projectile[index1][index2].rotation % (Math.PI/2) + Math.PI;
									}
								}
								if(projectile[index1][index2].phase <= 0 && maze[inTile(projectile[index1][index2].Xpos)+1][inTile(projectile[index1][index2].Ypos)+1].topWall + maze[inTile(projectile[index1][index2].Xpos)+1][inTile(projectile[index1][index2].Ypos)+1].leftWall + maze[inTile(projectile[index1][index2].Xpos)][inTile(projectile[index1][index2].Ypos)+1].topWall + maze[inTile(projectile[index1][index2].Xpos)+1][inTile(projectile[index1][index2].Ypos)].leftWall > 0){
									movementVector = distance((inTile(projectile[index1][index2].Xpos)+1)*tileSize - wallWidth, (inTile(projectile[index1][index2].Ypos)+1)*tileSize - wallWidth, projectile[index1][index2].Xpos, projectile[index1][index2].Ypos);
									if(movementVector < projectile[index1][index2].size){
										if(projectile[index1][index2].type == 9){
											projectile[index1][index2].timeLeft = Math.min(projectile[index1][index2].timeLeft, shrapnelFade);
											projectile[index1][index2].Xspeed = 0;
											projectile[index1][index2].Yspeed = 0;
											projectile[index1][index2].rotationSpeed = 0;
										}
										else{
											projectile[index1][index2].Xpos = (inTile(projectile[index1][index2].Xpos)+1)*tileSize - wallWidth + (projectile[index1][index2].Xpos - ((inTile(projectile[index1][index2].Xpos)+1)*tileSize - wallWidth))*projectile[index1][index2].size/movementVector;
											projectile[index1][index2].Ypos = (inTile(projectile[index1][index2].Ypos)+1)*tileSize - wallWidth + (projectile[index1][index2].Ypos - ((inTile(projectile[index1][index2].Ypos)+1)*tileSize - wallWidth))*projectile[index1][index2].size/movementVector;
											projectile[index1][index2].Xspeed = -Math.abs(projectile[index1][index2].Xspeed);
											projectile[index1][index2].Yspeed = -Math.abs(projectile[index1][index2].Yspeed);
										}
										//if(projectile[index1][index2].type == 6)projectile[index1][index2].rotation = projectile[index1][index2].rotation % (Math.PI/2) + Math.PI;
									}
								}
							
							}
							else {
								projectile[index1][index2].front.x = projectile[index1][index2].Xpos;
								projectile[index1][index2].front.y = projectile[index1][index2].Ypos;
								projectile[index1][index2].front.xS = projectile[index1][index2].Xspeed;
								projectile[index1][index2].front.yS = projectile[index1][index2].Yspeed;
								projectile[index1][index2].back.x = projectile[index1][index2].Xpos;
								projectile[index1][index2].back.y = projectile[index1][index2].Ypos;
								for(index3 = 0;index3 < projectile[index1][index2].updates;index3++){
									if(index3 == projectile[index1][index2].speed && projectile[index1][index2].timeLeft < baseProjectile[2].timeLeft - projectile[index1][index2].updates/projectile[index1][index2].speed){
										projectile[index1][index2].Xpos = projectile[index1][index2].front.x;
										projectile[index1][index2].Ypos = projectile[index1][index2].front.y;
										projectile[index1][index2].Xspeed = projectile[index1][index2].front.xS;
										projectile[index1][index2].Yspeed = projectile[index1][index2].front.yS;
									}
									
									projectile[index1][index2].front.x += projectile[index1][index2].front.xS;
									projectile[index1][index2].front.y += projectile[index1][index2].front.yS;
									
									laserBounce = false;
									if(projectile[index1][index2].phase - index3/projectile[index1][index2].speed <= 0){
										if(inTile(projectile[index1][index2].front.x - wallWidth - projectile[index1][index2].size) != inTile(projectile[index1][index2].front.x) && maze[inTile(projectile[index1][index2].front.x)][inTile(projectile[index1][index2].front.y)].leftWall == 1){
											wallPush = inTile(projectile[index1][index2].front.x)*tileSize + wallWidth + projectile[index1][index2].size  - projectile[index1][index2].front.x;
											projectile[index1][index2].front.x += wallPush;
											projectile[index1][index2].front.y += wallPush*projectile[index1][index2].front.yS/projectile[index1][index2].front.xS;
											projectile[index1][index2].front.xS = Math.abs(projectile[index1][index2].front.xS);
											laserBounce = true;
										}
										if(inTile(projectile[index1][index2].front.x + wallWidth + projectile[index1][index2].size) != inTile(projectile[index1][index2].front.x) && maze[inTile(projectile[index1][index2].front.x)+1][inTile(projectile[index1][index2].front.y)].leftWall == 1){
											wallPush = (inTile(projectile[index1][index2].front.x)+1)*tileSize - wallWidth - projectile[index1][index2].size  - projectile[index1][index2].front.x;
											projectile[index1][index2].front.x += wallPush;
											projectile[index1][index2].front.y += wallPush*projectile[index1][index2].front.yS/projectile[index1][index2].front.xS;
											projectile[index1][index2].front.xS = -Math.abs(projectile[index1][index2].front.xS);
											laserBounce = true;
										}
										if(inTile(projectile[index1][index2].front.y - wallWidth - projectile[index1][index2].size) != inTile(projectile[index1][index2].front.y) && maze[inTile(projectile[index1][index2].front.x)][inTile(projectile[index1][index2].front.y)].topWall == 1){
											wallPush = inTile(projectile[index1][index2].front.y)*tileSize + wallWidth + projectile[index1][index2].size  - projectile[index1][index2].front.y;
											projectile[index1][index2].front.y += wallPush;
											projectile[index1][index2].front.x += wallPush*projectile[index1][index2].front.xS/projectile[index1][index2].front.yS;
											projectile[index1][index2].front.yS = Math.abs(projectile[index1][index2].front.yS);
											laserBounce = true;
										}
										if(inTile(projectile[index1][index2].front.y + wallWidth + projectile[index1][index2].size) != inTile(projectile[index1][index2].front.y) && maze[inTile(projectile[index1][index2].front.x)][inTile(projectile[index1][index2].front.y)+1].topWall == 1){
											wallPush = (inTile(projectile[index1][index2].front.y)+1)*tileSize - wallWidth - projectile[index1][index2].size  - projectile[index1][index2].front.y;
											projectile[index1][index2].front.y += wallPush;
											projectile[index1][index2].front.x += wallPush*projectile[index1][index2].front.xS/projectile[index1][index2].front.yS;
											projectile[index1][index2].front.yS = -Math.abs(projectile[index1][index2].front.yS);
											laserBounce = true;
										}


										if(maze[inTile(projectile[index1][index2].front.x)][inTile(projectile[index1][index2].front.y)].topWall + maze[inTile(projectile[index1][index2].front.x)][inTile(projectile[index1][index2].front.y)].leftWall + maze[inTile(projectile[index1][index2].front.x)-1][inTile(projectile[index1][index2].front.y)].topWall + maze[inTile(projectile[index1][index2].front.x)][inTile(projectile[index1][index2].front.y)-1].leftWall > 0
										&& inTile(projectile[index1][index2].front.x - wallWidth - projectile[index1][index2].size) != inTile(projectile[index1][index2].front.x) && projectile[index1][index2].front.y > inTile(projectile[index1][index2].front.y - wallWidth)*tileSize - wallWidth && projectile[index1][index2].front.y < inTile(projectile[index1][index2].front.y)*tileSize + wallWidth){
											wallPush = inTile(projectile[index1][index2].front.x)*tileSize + wallWidth + projectile[index1][index2].size  - projectile[index1][index2].front.x;
											projectile[index1][index2].front.x += wallPush;
											projectile[index1][index2].front.y += wallPush*projectile[index1][index2].front.yS/projectile[index1][index2].front.xS;
											projectile[index1][index2].front.xS = Math.abs(projectile[index1][index2].front.xS);
											laserBounce = true;
										}
										if(maze[inTile(projectile[index1][index2].front.x)+1][inTile(projectile[index1][index2].front.y)].topWall + maze[inTile(projectile[index1][index2].front.x)+1][inTile(projectile[index1][index2].front.y)].leftWall + maze[inTile(projectile[index1][index2].front.x)][inTile(projectile[index1][index2].front.y)].topWall + maze[inTile(projectile[index1][index2].front.x)+1][inTile(projectile[index1][index2].front.y)-1].leftWall > 0
										&& inTile(projectile[index1][index2].front.x + wallWidth + projectile[index1][index2].size) != inTile(projectile[index1][index2].front.x) && projectile[index1][index2].front.y > inTile(projectile[index1][index2].front.y - wallWidth)*tileSize - wallWidth && projectile[index1][index2].front.y < inTile(projectile[index1][index2].front.y)*tileSize + wallWidth){
											wallPush = (inTile(projectile[index1][index2].front.x)+1)*tileSize - wallWidth - projectile[index1][index2].size  - projectile[index1][index2].front.x;
											projectile[index1][index2].front.x += wallPush;
											projectile[index1][index2].front.y += wallPush*projectile[index1][index2].front.yS/projectile[index1][index2].front.xS;
											projectile[index1][index2].front.xS = -Math.abs(projectile[index1][index2].front.xS);
											laserBounce = true;
										}
										if(maze[inTile(projectile[index1][index2].front.x)][inTile(projectile[index1][index2].front.y)].topWall + maze[inTile(projectile[index1][index2].front.x)][inTile(projectile[index1][index2].front.y)].leftWall + maze[inTile(projectile[index1][index2].front.x)-1][inTile(projectile[index1][index2].front.y)].topWall + maze[inTile(projectile[index1][index2].front.x)][inTile(projectile[index1][index2].front.y)-1].leftWall > 0
										&& inTile(projectile[index1][index2].front.y - wallWidth - projectile[index1][index2].size) != inTile(projectile[index1][index2].front.y) && projectile[index1][index2].front.x > inTile(projectile[index1][index2].front.x - wallWidth)*tileSize - wallWidth && projectile[index1][index2].front.x < inTile(projectile[index1][index2].front.x)*tileSize + wallWidth){
											wallPush = inTile(projectile[index1][index2].front.y)*tileSize + wallWidth + projectile[index1][index2].size  - projectile[index1][index2].front.y;
											projectile[index1][index2].front.y += wallPush;
											projectile[index1][index2].front.x += wallPush*projectile[index1][index2].front.xS/projectile[index1][index2].front.yS;
											projectile[index1][index2].front.yS = Math.abs(projectile[index1][index2].front.yS);
											laserBounce = true;
										}
										if(maze[inTile(projectile[index1][index2].front.x)][inTile(projectile[index1][index2].front.y)+1].topWall + maze[inTile(projectile[index1][index2].front.x)][inTile(projectile[index1][index2].front.y)+1].leftWall + maze[inTile(projectile[index1][index2].front.x)-1][inTile(projectile[index1][index2].front.y)+1].topWall + maze[inTile(projectile[index1][index2].front.x)][inTile(projectile[index1][index2].front.y)].leftWall > 0
										&& inTile(projectile[index1][index2].front.y + wallWidth + projectile[index1][index2].size) != inTile(projectile[index1][index2].front.y) && projectile[index1][index2].front.x > inTile(projectile[index1][index2].front.x - wallWidth)*tileSize - wallWidth && projectile[index1][index2].front.x < inTile(projectile[index1][index2].front.x)*tileSize + wallWidth){
											wallPush = (inTile(projectile[index1][index2].front.y)+1)*tileSize - wallWidth - projectile[index1][index2].size  - projectile[index1][index2].front.y;
											projectile[index1][index2].front.y += wallPush;
											projectile[index1][index2].front.x += wallPush*projectile[index1][index2].front.xS/projectile[index1][index2].front.yS;
											projectile[index1][index2].front.yS = -Math.abs(projectile[index1][index2].front.yS);
											laserBounce = true;
										}   ///save point


										if(maze[inTile(projectile[index1][index2].front.x)][inTile(projectile[index1][index2].front.y)].topWall + maze[inTile(projectile[index1][index2].front.x)][inTile(projectile[index1][index2].front.y)].leftWall + maze[inTile(projectile[index1][index2].front.x)-1][inTile(projectile[index1][index2].front.y)].topWall + maze[inTile(projectile[index1][index2].front.x)][inTile(projectile[index1][index2].front.y)-1].leftWall > 0){
											movementVector = distance(inTile(projectile[index1][index2].front.x)*tileSize + wallWidth, inTile(projectile[index1][index2].front.y)*tileSize + wallWidth, projectile[index1][index2].front.x, projectile[index1][index2].front.y);
											if(movementVector < projectile[index1][index2].size){
												projectile[index1][index2].front.x = inTile(projectile[index1][index2].front.x)*tileSize + wallWidth + (projectile[index1][index2].front.x - (inTile(projectile[index1][index2].front.x)*tileSize + wallWidth))*projectile[index1][index2].size/movementVector;
												projectile[index1][index2].front.y = inTile(projectile[index1][index2].front.y)*tileSize + wallWidth + (projectile[index1][index2].front.y - (inTile(projectile[index1][index2].front.y)*tileSize + wallWidth))*projectile[index1][index2].size/movementVector;
												projectile[index1][index2].front.xS = Math.abs(projectile[index1][index2].front.xS);
												projectile[index1][index2].front.yS = Math.abs(projectile[index1][index2].front.yS);
												laserBounce = true;
											}
										}
										if(maze[inTile(projectile[index1][index2].front.x)+1][inTile(projectile[index1][index2].front.y)].topWall + maze[inTile(projectile[index1][index2].front.x)+1][inTile(projectile[index1][index2].front.y)].leftWall + maze[inTile(projectile[index1][index2].front.x)][inTile(projectile[index1][index2].front.y)].topWall + maze[inTile(projectile[index1][index2].front.x)+1][inTile(projectile[index1][index2].front.y)-1].leftWall > 0){
											movementVector = distance((inTile(projectile[index1][index2].front.x)+1)*tileSize - wallWidth, inTile(projectile[index1][index2].front.y)*tileSize + wallWidth, projectile[index1][index2].front.x, projectile[index1][index2].front.y);
											if(movementVector < projectile[index1][index2].size){
												projectile[index1][index2].front.x = (inTile(projectile[index1][index2].front.x)+1)*tileSize - wallWidth + (projectile[index1][index2].front.x - ((inTile(projectile[index1][index2].front.x)+1)*tileSize - wallWidth))*projectile[index1][index2].size/movementVector;
												projectile[index1][index2].front.y = inTile(projectile[index1][index2].front.y)*tileSize + wallWidth + (projectile[index1][index2].front.y - (inTile(projectile[index1][index2].front.y)*tileSize + wallWidth))*projectile[index1][index2].size/movementVector;
												projectile[index1][index2].front.xS = -Math.abs(projectile[index1][index2].front.xS);
												projectile[index1][index2].front.yS = Math.abs(projectile[index1][index2].front.yS);
												laserBounce = true;
											}
										}
										if(maze[inTile(projectile[index1][index2].front.x)][inTile(projectile[index1][index2].front.y)+1].topWall + maze[inTile(projectile[index1][index2].front.x)][inTile(projectile[index1][index2].front.y)+1].leftWall + maze[inTile(projectile[index1][index2].front.x)-1][inTile(projectile[index1][index2].front.y)+1].topWall + maze[inTile(projectile[index1][index2].front.x)][inTile(projectile[index1][index2].front.y)].leftWall > 0){
											movementVector = distance(inTile(projectile[index1][index2].front.x)*tileSize + wallWidth, (inTile(projectile[index1][index2].front.y)+1)*tileSize - wallWidth, projectile[index1][index2].front.x, projectile[index1][index2].front.y);
											if(movementVector < projectile[index1][index2].size){
												projectile[index1][index2].front.x = inTile(projectile[index1][index2].front.x)*tileSize + wallWidth + (projectile[index1][index2].front.x - (inTile(projectile[index1][index2].front.x)*tileSize + wallWidth))*projectile[index1][index2].size/movementVector;
												projectile[index1][index2].front.y = (inTile(projectile[index1][index2].front.y)+1)*tileSize - wallWidth + (projectile[index1][index2].front.y - ((inTile(projectile[index1][index2].front.y)+1)*tileSize - wallWidth))*projectile[index1][index2].size/movementVector;
												projectile[index1][index2].front.xS = Math.abs(projectile[index1][index2].front.xS);
												projectile[index1][index2].front.yS = -Math.abs(projectile[index1][index2].front.yS);
												laserBounce = true;
											}
										}
										if(maze[inTile(projectile[index1][index2].front.x)+1][inTile(projectile[index1][index2].front.y)+1].topWall + maze[inTile(projectile[index1][index2].front.x)+1][inTile(projectile[index1][index2].front.y)+1].leftWall + maze[inTile(projectile[index1][index2].front.x)][inTile(projectile[index1][index2].front.y)+1].topWall + maze[inTile(projectile[index1][index2].front.x)+1][inTile(projectile[index1][index2].front.y)].leftWall > 0){
											movementVector = distance((inTile(projectile[index1][index2].front.x)+1)*tileSize - wallWidth, (inTile(projectile[index1][index2].front.y)+1)*tileSize - wallWidth, projectile[index1][index2].front.x, projectile[index1][index2].front.y);
											if(movementVector < projectile[index1][index2].size){
												projectile[index1][index2].front.x = (inTile(projectile[index1][index2].front.x)+1)*tileSize - wallWidth + (projectile[index1][index2].front.x - ((inTile(projectile[index1][index2].front.x)+1)*tileSize - wallWidth))*projectile[index1][index2].size/movementVector;
												projectile[index1][index2].front.y = (inTile(projectile[index1][index2].front.y)+1)*tileSize - wallWidth + (projectile[index1][index2].front.y - ((inTile(projectile[index1][index2].front.y)+1)*tileSize - wallWidth))*projectile[index1][index2].size/movementVector;
												projectile[index1][index2].front.xS = -Math.abs(projectile[index1][index2].front.xS);
												projectile[index1][index2].front.yS = -Math.abs(projectile[index1][index2].front.yS);
												laserBounce = true;
											}
										}
									}
									
									
									var kill = false;
									var killTanks = [];
									var index4 = 0;
									var index5 = 0;
									var index6 = 0;

									for(index6 = 0;index6 < players;index6++){
										if(!player[index6].dead && distance(projectile[index1][index2].front.x, projectile[index1][index2].front.y, player[index6].Xpos, player[index6].Ypos) <= tankScale*Math.sqrt(13) + projectile[index1][index2].size){
											playerAxis = getPlayerAxis(index6);
											for(index4 = 0;index4 < 4;index4++){
												killTanks = playerCollisions(projectile[index1][index2].front.x + playerAxis[index4].x * projectile[index1][index2].size, projectile[index1][index2].front.y + playerAxis[index4].y * projectile[index1][index2].size);
												for(index5 = 0;index5 < killTanks.length;index5++){
													kill = true;
													player[killTanks[index5]].dead = true;
													player[killTanks[index5]].deaths++;
													if(index1 != killTanks[index5]) player[index1].kills++;
												}
											}
										}
									}
									if(kill){
										projectile[index1][index2].timeLeft = Math.min(projectile[index1][index2].timeLeft, Math.ceil(index3/projectile[index1][index2].speed));
										laserBounce = true;
									}
									
									
									
									if(index3 == projectile[index1][index2].updates - 1 || projectile[index1][index2].timeLeft - index3/projectile[index1][index2].speed < 0 || projectile[index1][index2].timeLeft + index3/projectile[index1][index2].speed > baseProjectile[2].timeLeft) laserBounce = true;
									
									if(laserBounce){
										ctx.beginPath();
										ctx.arc(border.x + mazeBorder.x + projectile[index1][index2].front.x * scale, border.y + mazeBorder.y + projectile[index1][index2].front.y * scale, projectile[index1][index2].size * scale, 0, Math.PI*2);
										ctx.fillStyle = playerColor[index1];
										ctx.fill();
										ctx.closePath();
										ctx.beginPath();
										ctx.moveTo(border.x + mazeBorder.x + projectile[index1][index2].front.x * scale, border.y + mazeBorder.y + projectile[index1][index2].front.y * scale);
										ctx.lineTo(border.x + mazeBorder.x + projectile[index1][index2].back.x * scale, border.y + mazeBorder.y + projectile[index1][index2].back.y * scale);
										ctx.strokeStyle = playerColor[index1];
										ctx.lineWidth = projectile[index1][index2].size * scale * 2;
										ctx.stroke();
										ctx.closePath();
										
										projectile[index1][index2].back.x = projectile[index1][index2].front.x;
										projectile[index1][index2].back.y = projectile[index1][index2].front.y;
										
										if(projectile[index1][index2].timeLeft - index3/projectile[index1][index2].speed < 0 || projectile[index1][index2].timeLeft + index3/projectile[index1][index2].speed > baseProjectile[2].timeLeft){break;}
									}
								}
							}
							if(projectile[index1][index2].type == 4){
								projectile[index1][index2].Xspeed *= 0.8;
								projectile[index1][index2].Yspeed *= 0.8;
							}
							if(projectile[index1][index2].phase > 0) projectile[index1][index2].phase--;
							projectile[index1][index2].timeLeft--;
							if(projectile[index1][index2].timeLeft == 0){
								onKill(index1, index2);
								projectile[index1][index2].dead = true;
							}
						}
					}
				}
			}
			function wallBounce(target, realTarget = target){
				
				if(realTarget.phase <= 0 && inTile(target.Xpos - wallWidth - realTarget.size) != inTile(target.Xpos) && maze[inTile(target.Xpos)][inTile(target.Ypos)].leftWall == 1
				   || maze[inTile(target.Xpos - wallWidth - realTarget.size)][inTile(target.Ypos)].tile == 1){
					target.Xpos = inTile(target.Xpos)*tileSize + wallWidth + realTarget.size;
					target.Xspeed *= -1;
					if(realTarget.type == 9){
						target.timeLeft = Math.min(target.timeLeft, shrapnelFade);
						target.Xspeed = 0;
						target.Yspeed = 0;
						target.rotationSpeed = 0;
					}
					if(realTarget.type == 6)target.rotation *= -1;
				}
				if(realTarget.phase <= 0 && inTile(target.Xpos + wallWidth + realTarget.size) != inTile(target.Xpos) && maze[inTile(target.Xpos)+1][inTile(target.Ypos)].leftWall == 1
				   || maze[inTile(target.Xpos + wallWidth + realTarget.size)][inTile(target.Ypos)].tile == 1){
					target.Xpos = (inTile(target.Xpos)+1)*tileSize - wallWidth - realTarget.size;
					target.Xspeed *= -1;
					if(realTarget.type == 9){
						target.timeLeft = Math.min(target.timeLeft, shrapnelFade);
						target.Xspeed = 0;
						target.Yspeed = 0;
						target.rotationSpeed = 0;
					}
					if(realTarget.type == 6)target.rotation *= -1;
				}
				if(realTarget.phase <= 0 && inTile(target.Ypos - wallWidth - realTarget.size) != inTile(target.Ypos) && maze[inTile(target.Xpos)][inTile(target.Ypos)].topWall == 1
				   || maze[inTile(target.Xpos)][inTile(target.Ypos - wallWidth - realTarget.size)].tile == 1){
					target.Ypos = inTile(target.Ypos)*tileSize + wallWidth + realTarget.size;
					target.Yspeed *= -1;
					if(realTarget.type == 9){
						target.timeLeft = Math.min(target.timeLeft, shrapnelFade);
						target.Xspeed = 0;
						target.Yspeed = 0;
						target.rotationSpeed = 0;
					}
					if(realTarget.type == 6)target.rotation = Math.PI - target.rotation;
				}
				if(realTarget.phase <= 0 && inTile(target.Ypos + wallWidth + realTarget.size) != inTile(target.Ypos) && maze[inTile(target.Xpos)][inTile(target.Ypos)+1].topWall == 1
				   || maze[inTile(target.Xpos)][inTile(target.Ypos + wallWidth + realTarget.size)].tile == 1){
					target.Ypos = (inTile(target.Ypos)+1)*tileSize - wallWidth - realTarget.size;
					target.Yspeed *= -1;
					if(realTarget.type == 9){
						target.timeLeft = Math.min(target.timeLeft, shrapnelFade);
						target.Xspeed = 0;
						target.Yspeed = 0;
						target.rotationSpeed = 0;
					}
					if(realTarget.type == 6)target.rotation = Math.PI - target.rotation;
				}
				
				if(realTarget.phase <= 0 && maze[inTile(projectile[index1][index2].Xpos)][inTile(projectile[index1][index2].Ypos)].topWall + maze[inTile(projectile[index1][index2].Xpos)][inTile(projectile[index1][index2].Ypos)].leftWall + maze[inTile(projectile[index1][index2].Xpos)-1][inTile(projectile[index1][index2].Ypos)].topWall + maze[inTile(projectile[index1][index2].Xpos)][inTile(projectile[index1][index2].Ypos)-1].leftWall > 0
				   && inTile(projectile[index1][index2].Xpos - wallWidth - realTarget.size) != inTile(projectile[index1][index2].Xpos) && projectile[index1][index2].Ypos > inTile(projectile[index1][index2].Ypos)*tileSize - wallWidth && projectile[index1][index2].Ypos < inTile(projectile[index1][index2].Ypos)*tileSize + wallWidth
				   /*|| maze[inTile(projectile[index1][index2].Xpos - wallWidth - realTarget.size)][inTile(projectile[index1][index2].Ypos - wallWidth - realTarget.size)].tile  +  maze[inTile(projectile[index1][index2].Xpos - wallWidth - realTarget.size)][inTile(projectile[index1][index2].Ypos + wallWidth + realTarget.size)].tile > 0*/){
					projectile[index1][index2].Xpos = inTile(projectile[index1][index2].Xpos)*tileSize + wallWidth + realTarget.size;
					if(realTarget.type == 9){
						projectile[index1][index2].timeLeft = Math.min(projectile[index1][index2].timeLeft, shrapnelFade);
						projectile[index1][index2].Xspeed = 0;
						projectile[index1][index2].Yspeed = 0;
						projectile[index1][index2].rotationSpeed = 0;
					}
					else{
						projectile[index1][index2].Xspeed *= -1;
					}
					//if(realTarget.type == 6)projectile[index1][index2].rotation *= -1;
				}
				if(realTarget.phase <= 0 && maze[inTile(projectile[index1][index2].Xpos)+1][inTile(projectile[index1][index2].Ypos)].topWall + maze[inTile(projectile[index1][index2].Xpos)+1][inTile(projectile[index1][index2].Ypos)].leftWall + maze[inTile(projectile[index1][index2].Xpos)][inTile(projectile[index1][index2].Ypos)].topWall + maze[inTile(projectile[index1][index2].Xpos)+1][inTile(projectile[index1][index2].Ypos)-1].leftWall > 0
				   && inTile(projectile[index1][index2].Xpos + wallWidth + realTarget.size) != inTile(projectile[index1][index2].Xpos) && projectile[index1][index2].Ypos > inTile(projectile[index1][index2].Ypos)*tileSize - wallWidth && projectile[index1][index2].Ypos < inTile(projectile[index1][index2].Ypos)*tileSize + wallWidth){
					if(realTarget.type == 9){
						projectile[index1][index2].timeLeft = Math.min(projectile[index1][index2].timeLeft, shrapnelFade);
						projectile[index1][index2].Xspeed = 0;
						projectile[index1][index2].Yspeed = 0;
						projectile[index1][index2].rotationSpeed = 0;
					}
					else{
						projectile[index1][index2].Xpos = (inTile(projectile[index1][index2].Xpos)+1)*tileSize - wallWidth - realTarget.size;
						projectile[index1][index2].Xspeed *= -1;
					}
					//if(realTarget.type == 6)projectile[index1][index2].rotation *= -1;
				}
				if(realTarget.phase <= 0 && maze[inTile(projectile[index1][index2].Xpos)][inTile(projectile[index1][index2].Ypos)].topWall + maze[inTile(projectile[index1][index2].Xpos)][inTile(projectile[index1][index2].Ypos)].leftWall + maze[inTile(projectile[index1][index2].Xpos)-1][inTile(projectile[index1][index2].Ypos)].topWall + maze[inTile(projectile[index1][index2].Xpos)][inTile(projectile[index1][index2].Ypos)-1].leftWall > 0
				   && inTile(projectile[index1][index2].Ypos - wallWidth - realTarget.size) != inTile(projectile[index1][index2].Ypos) && projectile[index1][index2].Xpos > inTile(projectile[index1][index2].Xpos)*tileSize - wallWidth && projectile[index1][index2].Xpos < inTile(projectile[index1][index2].Xpos)*tileSize + wallWidth){
					if(realTarget.type == 9){
						projectile[index1][index2].timeLeft = Math.min(projectile[index1][index2].timeLeft, shrapnelFade);
						projectile[index1][index2].Xspeed = 0;
						projectile[index1][index2].Yspeed = 0;
						projectile[index1][index2].rotationSpeed = 0;
					}
					else{
						projectile[index1][index2].Ypos = inTile(projectile[index1][index2].Ypos)*tileSize + wallWidth + realTarget.size;
						projectile[index1][index2].Yspeed *= -1;
					}
					//if(realTarget.type == 6)projectile[index1][index2].rotation = Math.PI - projectile[index1][index2].rotation;
				}
				if(realTarget.phase <= 0 && maze[inTile(projectile[index1][index2].Xpos)][inTile(projectile[index1][index2].Ypos)+1].topWall + maze[inTile(projectile[index1][index2].Xpos)][inTile(projectile[index1][index2].Ypos)+1].leftWall + maze[inTile(projectile[index1][index2].Xpos)-1][inTile(projectile[index1][index2].Ypos)+1].topWall + maze[inTile(projectile[index1][index2].Xpos)][inTile(projectile[index1][index2].Ypos)].leftWall > 0
				   && inTile(projectile[index1][index2].Ypos + wallWidth + projectile[index1][index2].size) != inTile(projectile[index1][index2].Ypos) && projectile[index1][index2].Xpos > inTile(projectile[index1][index2].Xpos)*tileSize - wallWidth && projectile[index1][index2].Xpos < inTile(projectile[index1][index2].Xpos)*tileSize + wallWidth){
					if(realTarget.type == 9){
						projectile[index1][index2].timeLeft = Math.min(projectile[index1][index2].timeLeft, shrapnelFade);
						projectile[index1][index2].Xspeed = 0;
						projectile[index1][index2].Yspeed = 0;
						projectile[index1][index2].rotationSpeed = 0;
					}
					else{
						projectile[index1][index2].Ypos = (inTile(projectile[index1][index2].Ypos)+1)*tileSize - wallWidth - projectile[index1][index2].size;
						projectile[index1][index2].Yspeed *= -1;
					}
					//if(realTarget.type == 6)projectile[index1][index2].rotation = Math.PI - projectile[index1][index2].rotation;
				}
			}
			
			function onKill(owner, target){
				if(projectile[owner][target].type == 1 || projectile[owner][target].type == 4){
					shoot(owner, 9, 20, Math.PI*2, true, {speed:projectile[owner][target].speedVector/baseProjectile[projectile[owner][target].type].speedVector, phase:projectile[owner][target].phase}, false, projectile[owner][target].Xpos, projectile[owner][target].Ypos, 0);
				}
				else if(projectile[owner][target].frag){
					
					if(projectile[owner][target].type == 2){}
				}
			}
			
			function drawMaze(){
				for(index1 = 0;index1 < maze.width + 2;index1++){
					for(index2 = 0;index2 < maze.height + 2;index2++){
						ctx.beginPath();
						ctx.rect(border.x + mazeBorder.x + index1*tileSize*scale, border.y + mazeBorder.y + index2*tileSize*scale, tileSize*scale + 1, tileSize*scale + 1);
						ctx.fillStyle = maze[index1][index2].tile == 1 ? "#CCCCCC" : "White";
						ctx.fill();
						ctx.closePath();
					}
				}
				for(index1 = 1;index1 < maze.width + 2;index1++){
					for(index2 = 1;index2 < maze.height + 2;index2++){
						if(maze[index1][index2].leftWall == 1){
							ctx.beginPath();
							ctx.rect(border.x + mazeBorder.x + Math.floor((index1*tileSize - wallWidth)*scale), border.y + mazeBorder.y + Math.floor((index2*tileSize + wallWidth)*scale), Math.ceil((wallWidth*2)*scale), Math.ceil((tileSize - wallWidth*2)*scale));
							ctx.fillStyle = "Gray";
							ctx.fill();
							ctx.closePath();
						}
						if(maze[index1][index2].topWall == 1){
							ctx.beginPath();
							ctx.rect(border.x + mazeBorder.x + Math.floor((index1*tileSize + wallWidth)*scale), border.y + mazeBorder.y + Math.floor((index2*tileSize - wallWidth)*scale), Math.ceil((tileSize - wallWidth*2)*scale), Math.ceil((wallWidth*2)*scale));
							ctx.fillStyle = "Gray";
							ctx.fill();
							ctx.closePath();
						}
						if(maze[index1][index2].topWall + maze[index1][index2].leftWall + maze[index1-1][index2].topWall + maze[index1][index2-1].leftWall > 0){
							ctx.beginPath();
							ctx.rect(border.x + mazeBorder.x + Math.floor((index1*tileSize - wallWidth)*scale), border.y + mazeBorder.y + Math.floor((index2*tileSize - wallWidth)*scale), Math.ceil((wallWidth*2)*scale), Math.ceil((wallWidth*2)*scale));
							ctx.fillStyle = "Gray";
							ctx.fill();
							ctx.closePath();
						}
					}
				}
			}
			function drawProjectiles(){
				for(index1 = 0;index1 < players;index1++){
					for(index2 = 0;index2 < projectile[index1].length;index2++){
						proj = projectile[index1][index2];
						if(!proj.dead){
							if(proj.type != 2 && proj.type != 6 && proj.type != 9){
								ctx.beginPath();
								ctx.arc(border.x + mazeBorder.x + proj.Xpos * scale, border.y + mazeBorder.y + proj.Ypos * scale, proj.size * scale, 0, Math.PI*2);
								ctx.fillStyle = "Black";
								if(projectile[index1][index2].type == 4){
									ctx.fillStyle = playerColor[index1];
									ctx.strokeStyle = "Black";
									ctx.lineWidth = 0.25*scale*tankScale;
									ctx.globalAlpha = proj.timeLeft < mineDelay ? 1 - (proj.timeLeft / mineDelay) : (baseProjectile[4].timeLeft - proj.timeLeft < mineDelay ? 1 - (baseProjectile[4].timeLeft - proj.timeLeft)/mineDelay : 0);
									ctx.stroke();
								}
								ctx.fill();
								ctx.closePath();
							}
							if(projectile[index1][index2].type == 6){
								ctx.beginPath();
								ctx.moveTo(border.x + mazeBorder.x + (proj.Xpos + Math.sin(proj.rotation                )*proj.size)*scale, border.y + mazeBorder.y + (proj.Ypos + Math.cos(proj.rotation                )*proj.size)*scale);
								ctx.lineTo(border.x + mazeBorder.x + (proj.Xpos + Math.sin(proj.rotation + Math.PI + 0.6)*proj.size)*scale, border.y + mazeBorder.y + (proj.Ypos + Math.cos(proj.rotation + Math.PI + 0.6)*proj.size)*scale);
								ctx.lineTo(border.x + mazeBorder.x + (proj.Xpos + Math.sin(proj.rotation + Math.PI - 0.6)*proj.size)*scale, border.y + mazeBorder.y + (proj.Ypos + Math.cos(proj.rotation + Math.PI - 0.6)*proj.size)*scale);
								ctx.lineTo(border.x + mazeBorder.x + (proj.Xpos + Math.sin(proj.rotation                )*proj.size)*scale, border.y + mazeBorder.y + (proj.Ypos + Math.cos(proj.rotation                )*proj.size)*scale);
								ctx.fillStyle = playerColor[index1];
								ctx.fill();
								ctx.strokeStyle = "Black";
								ctx.lineWidth = 0.25*scale*tankScale;
								ctx.stroke();
								ctx.closePath();
							}
							if(projectile[index1][index2].type == 9){
								ctx.beginPath();
								ctx.moveTo(border.x + mazeBorder.x + (proj.Xpos + Math.sin(proj.rotation + proj.corner[0])*proj.size)*scale, border.y + mazeBorder.y + (proj.Ypos + Math.cos(proj.rotation + proj.corner[0])*proj.size)*scale);
								ctx.lineTo(border.x + mazeBorder.x + (proj.Xpos + Math.sin(proj.rotation + proj.corner[1])*proj.size)*scale, border.y + mazeBorder.y + (proj.Ypos + Math.cos(proj.rotation + proj.corner[1])*proj.size)*scale);
								ctx.lineTo(border.x + mazeBorder.x + (proj.Xpos + Math.sin(proj.rotation + proj.corner[2])*proj.size)*scale, border.y + mazeBorder.y + (proj.Ypos + Math.cos(proj.rotation + proj.corner[2])*proj.size)*scale);
								ctx.lineTo(border.x + mazeBorder.x + (proj.Xpos + Math.sin(proj.rotation + proj.corner[0])*proj.size)*scale, border.y + mazeBorder.y + (proj.Ypos + Math.cos(proj.rotation + proj.corner[0])*proj.size)*scale);
								ctx.globalAlpha = Math.min(projectile[index1][index2].timeLeft / (shrapnelFade/2), 1);
								ctx.fillStyle = "Black";
								ctx.fill();
								ctx.globalAlpha = 1;
								ctx.closePath();
							}
							ctx.globalAlpha = 1;
						}
					}
				}
			}
			function drawTanks(){
				for(index1 = 0;index1 < players;index1++){ //0.43643834422
					if(!player[index1].dead){
						getTankCorners(index1);
						
						ctx.beginPath();
						ctx.moveTo(border.x + mazeBorder.x + tankCorner[index1][0].x*scale, border.y + mazeBorder.y + tankCorner[index1][0].y*scale);
						ctx.lineTo(border.x + mazeBorder.x + tankCorner[index1][1].x*scale, border.y + mazeBorder.y + tankCorner[index1][1].y*scale);
						ctx.lineTo(border.x + mazeBorder.x + tankCorner[index1][2].x*scale, border.y + mazeBorder.y + tankCorner[index1][2].y*scale);
						ctx.lineTo(border.x + mazeBorder.x + tankCorner[index1][3].x*scale, border.y + mazeBorder.y + tankCorner[index1][3].y*scale);
						ctx.lineTo(border.x + mazeBorder.x + tankCorner[index1][0].x*scale, border.y + mazeBorder.y + tankCorner[index1][0].y*scale);
						ctx.fillStyle = playerColor[index1 % playerColor.length];
						ctx.fill();
						ctx.strokeStyle = "Black";
						ctx.lineWidth = 0.25*scale*tankScale;
						ctx.stroke();
						ctx.closePath();
						
						ctx.beginPath();
						ctx.moveTo(border.x + mazeBorder.x + player[index1].Xpos*scale + Math.sin(Math.atan( 0.17) + player[index1].rotation)*scale*tankScale*Math.sqrt(16.4624), border.y + mazeBorder.y + player[index1].Ypos*scale + Math.cos(Math.atan(0.17)  + player[index1].rotation)*scale*tankScale*Math.sqrt(16.4624));
						ctx.lineTo(border.x + mazeBorder.x + player[index1].Xpos*scale + Math.sin(Math.atan(-0.17) + player[index1].rotation)*scale*tankScale*Math.sqrt(16.4624), border.y + mazeBorder.y + player[index1].Ypos*scale + Math.cos(Math.atan(-0.17) + player[index1].rotation)*scale*tankScale*Math.sqrt(16.4624));
						ctx.arc(border.x + mazeBorder.x + player[index1].Xpos*scale, border.y + mazeBorder.y + player[index1].Ypos*scale, 1.5*scale*tankScale, Math.PI/2 + Math.atan(0.50859824365) - player[index1].rotation, Math.PI/2 - Math.atan(0.50859824365) - player[index1].rotation);
						ctx.lineTo(border.x + mazeBorder.x + player[index1].Xpos*scale + Math.sin(Math.atan( 0.17) + player[index1].rotation)*scale*tankScale*Math.sqrt(16.4624), border.y + mazeBorder.y + player[index1].Ypos*scale + Math.cos(Math.atan(0.17)  + player[index1].rotation)*scale*tankScale*Math.sqrt(16.4624));
						ctx.fill();
						ctx.stroke();
						ctx.closePath();
					}
				}
			}
			function drawScores(){  //and active powerups and modifiers
				for(index1 = 0;index1 < players;index1++){
					ctx.beginPath();
					ctx.arc(border.x + (index1 + 1)/(players + 1) * (canvas.width - border.x*2), canvas.height - scoreArea*3/2, 15, 0, Math.PI*2);
					ctx.fillStyle = playerColor[index1 % playerColor.length];
					ctx.fill();
					ctx.closePath();
					
					if(player[index1].powerUp > 0){
						drawPickup(player[index1].powerUp, false, border.x + (index1 + 1)/(players + 1) * (canvas.width - border.x*2) - (player[index1].modifier > 0 ? 15:0), canvas.height - scoreArea*3/2 + 38, 0, 16);
					}
					if(player[index1].modifier > 0){
						drawPickup(player[index1].modifier, true, border.x + (index1 + 1)/(players + 1) * (canvas.width - border.x*2) + (player[index1].powerUp > 0 ? 15:0), canvas.height - scoreArea*3/2 + 38, 0, 16);
					}
					
					ctx.beginPath();
					ctx.font = "20px Arial";
		    			ctx.fillStyle = "Black";
					ctx.fillText("Kills: " + player[index1].kills, border.x + (index1 + 1)/(players + 1) * (canvas.width - border.x*2) - 30, canvas.height - scoreArea/2);
					ctx.fillText("Deaths: " + player[index1].deaths, border.x + (index1 + 1)/(players + 1) * (canvas.width - border.x*2) - 30, canvas.height - scoreArea/2 + 20);
					ctx.fillText("Wins: " + player[index1].score, border.x + (index1 + 1)/(players + 1) * (canvas.width - border.x*2) - 30, canvas.height - scoreArea/2 + 40);
					ctx.closePath();
				}
			}
			function drawPowerups(){
				for(index1 = 0;index1 < powerUp.length;index1++){
					if(!powerUp[index1].dead){
						drawPickup(powerUp[index1].type, powerUp[index1].modifier, border.x + mazeBorder.x + powerUp[index1].Xpos*scale, border.y + mazeBorder.y + powerUp[index1].Ypos*scale, powerUp[index1].rotation);
					}
				}
			}
			function drawPickup(type, modifier, x, y, r, pickupScale = 15*scale){
				ctx.beginPath();
				ctx.moveTo(x + Math.sin(Math.PI*1/4 + r)*pickupScale, y + Math.cos(Math.PI*1/4 + r)*pickupScale);
				ctx.lineTo(x + Math.sin(Math.PI*3/4 + r)*pickupScale, y + Math.cos(Math.PI*3/4 + r)*pickupScale);
				ctx.lineTo(x + Math.sin(Math.PI*5/4 + r)*pickupScale, y + Math.cos(Math.PI*5/4 + r)*pickupScale);
				ctx.lineTo(x + Math.sin(Math.PI*7/4 + r)*pickupScale, y + Math.cos(Math.PI*7/4 + r)*pickupScale);
				ctx.lineTo(x + Math.sin(Math.PI*1/4 + r)*pickupScale, y + Math.cos(Math.PI*1/4 + r)*pickupScale);
				ctx.fillStyle = modifier? "#AAAAAA":"#BBBBBB";
				ctx.fill();
				ctx.strokeStyle = modifier? "#888888":"#999999";
				ctx.lineWidth = 0.25*pickupScale/15*tankScale;
				ctx.stroke();
				ctx.closePath();
				
				ctx.beginPath();
				ctx.moveTo(x + Math.sin(Math.PI*1/4 + r)*pickupScale*pickupBorder, y + Math.cos(Math.PI*1/4 + r)*pickupScale*pickupBorder);
				ctx.lineTo(x + Math.sin(Math.PI*3/4 + r)*pickupScale*pickupBorder, y + Math.cos(Math.PI*3/4 + r)*pickupScale*pickupBorder);
				ctx.lineTo(x + Math.sin(Math.PI*5/4 + r)*pickupScale*pickupBorder, y + Math.cos(Math.PI*5/4 + r)*pickupScale*pickupBorder);
				ctx.lineTo(x + Math.sin(Math.PI*7/4 + r)*pickupScale*pickupBorder, y + Math.cos(Math.PI*7/4 + r)*pickupScale*pickupBorder);
				ctx.lineTo(x + Math.sin(Math.PI*1/4 + r)*pickupScale*pickupBorder, y + Math.cos(Math.PI*1/4 + r)*pickupScale*pickupBorder);
				ctx.fillStyle = modifier? "#888888":"#999999";
				ctx.fill();
				ctx.closePath();
				
				if(modifier){
					if(type == 1){
						ctx.beginPath();
						ctx.arc(x + Math.sin(r + Math.PI/2)*pickupScale*pickupBorder*0.3, y + Math.cos(r + Math.PI/2)*pickupScale*pickupBorder*0.3, pickupScale/8, 0, Math.PI*2);
						ctx.fillStyle = "#666666";
						ctx.fill();
						ctx.closePath();
					}
					if(type == 3){
						ctx.fillStyle = "#666666";
						for(var index4 = 0;index4 < 3;index4++){
							ctx.beginPath();
							ctx.arc(x + (Math.sin(r + (index4 + 0.5)/3 * Math.PI*2) + Math.sin(r)*0.2)*pickupScale*pickupBorder*0.4, y + (Math.cos(r + (index4 + 0.5)/3 * Math.PI*2) + Math.cos(r)*0.2)*pickupScale*pickupBorder*0.4, pickupScale/6, 0, Math.PI*2);
							ctx.fill();
							ctx.closePath();
						}
					}
				}
				else{
					if(type == 1){
						ctx.beginPath();
						ctx.moveTo(x,y);
						for(var index4 = 0;index4 < 17;index4++){
							ctx.lineTo(x + Math.sin(r + index4/16 * Math.PI*2)*pickupScale*pickupBorder*(0.58 - (index4 % 2) * 0.27), y + Math.cos(r + index4/16 * Math.PI*2)*pickupScale*pickupBorder*(0.58 - (index4 % 2) * 0.27));
						}
						ctx.fillStyle = "#666666";
						ctx.fill();
						ctx.closePath();
					}
					if(type == 2){
						ctx.beginPath();
						ctx.moveTo(x + Math.sin(r - Math.PI/4)*pickupScale*pickupBorder*0.7, y + Math.cos(r - Math.PI/4)*pickupScale*pickupBorder*0.7);
						ctx.lineTo(x + Math.sin(r + Math.PI/4 + Math.PI)*pickupScale*pickupBorder*0.2, y + Math.cos(r + Math.PI/4 + Math.PI)*pickupScale*pickupBorder*0.2);
						ctx.lineTo(x + Math.sin(r + Math.PI/4)*pickupScale*pickupBorder*0.2, y + Math.cos(r + Math.PI/4)*pickupScale*pickupBorder*0.2);
						ctx.lineTo(x + Math.sin(r - Math.PI/4 + Math.PI)*pickupScale*pickupBorder*0.7, y + Math.cos(r - Math.PI/4 + Math.PI)*pickupScale*pickupBorder*0.7);
						ctx.strokeStyle = "#666666";
						ctx.lineWidth = 0.5*pickupScale/15*tankScale;
						ctx.stroke();
						ctx.closePath();
					}
					if(type == 3){
						ctx.fillStyle = "#666666";
						for(var index4 = 0;index4 < 8;index4++){
							ctx.beginPath();
							ctx.arc(x + Math.sin(r + index4/8 * Math.PI*2)*pickupScale*pickupBorder*0.45, y + Math.cos(r + index4/8 * Math.PI*2)*pickupScale*pickupBorder*0.45, pickupScale/11, 0, Math.PI*2);
							ctx.fill();
							ctx.closePath();
						}
					}
					if(type == 4){
						
					}
					if(type == 5){
						
					}
					if(type == 6){
						ctx.beginPath();
						ctx.arc(x + Math.sin(r)*pickupScale*pickupBorder*0.38, y + Math.cos(r)*pickupScale*pickupBorder*0.38, pickupScale/13, 0, Math.PI*2);
						ctx.fillStyle = "#666666";
						ctx.fill();
						ctx.strokeStyle = "#666666";
						ctx.lineWidth = 0.5*pickupScale/15*tankScale;
						ctx.closePath();
						for(var index4 = 1;index4 <= 3;index4++){
							ctx.beginPath();
							ctx.arc(x + Math.sin(r)*pickupScale*pickupBorder*0.38, y + Math.cos(r)*pickupScale*pickupBorder*0.38, pickupScale/4.5 * index4, -(r + 0.65 + Math.PI/2), -(r - 0.65 + Math.PI/2));
							ctx.stroke();
							ctx.closePath();
						}
					}
				}
			}
			function spawnPickup(){
				for(index3 = 0;index3 < powerUp.length && !powerUp[index3].dead;index3++){}
				stop = false;
				var index5 = 0;
				while(!stop){
					index1 = Math.floor(Math.random()*(maze.width + 1));
					index2 = Math.floor(Math.random()*(maze.height + 1));

					if(maze[index1][index2].tile == 0){
						powerUp[index3].Xpos = (index1 + 0.5)*tileSize;
						powerUp[index3].Ypos = (index2 + 0.5)*tileSize;
						powerUp[index3].rotation = Math.random()*0.4 - 0.2;
						powerUp[index3].dead = false;
						powerUp[index3].modifier = Math.random() < modifierChance ? true:false;
						powerUp[index3].type = Math.floor(Math.random()*(powerUp[index3].modifier ? 3:6))+1;
						stop = true;
					}
					for(var index4 = 0;index4 < powerUp.length;index4++){
						if(index4 != index3 && distance(powerUp[index3].Xpos, powerUp[index3].Ypos, powerUp[index4].Xpos, powerUp[index4].Ypos) < tileSize*3){
							stop = false;
						}
					}
					if(index5 > 100){
						powerUp[index3].dead = true;
						stop = true;
					}
					index5++;
				}
			}
			
			
			function playerCollisions(x,y){
				var collisions = [];
				var check = true;
				var cornerAngle = 0;
				var checkAngle = 0;
				var index4,index5 = 0;
				for(index4 = 0;index4 < players;index4++){
					if(!player[index4].dead){
						check = true;
						getTankCorners(index4);
						for(index5 = 0;index5 < 4;index5++){
							checkAngle = Math.atan((y - tankCorner[index4][index5].y)/(x - tankCorner[index4][index5].x)) + Math.PI/2;
							if(x < tankCorner[index4][index5].x) checkAngle += Math.PI;
							
							cornerAngle = Math.atan((tankCorner[index4][(index5+1)%4].y - tankCorner[index4][index5].y)/(tankCorner[index4][(index5+1)%4].x - tankCorner[index4][index5].x)) + Math.PI/2;
							if(tankCorner[index4][(index5+1)%4].x < tankCorner[index4][index5].x) cornerAngle += Math.PI;
							
							if(Math.abs(cornerAngle - checkAngle) % (Math.PI*2) >= Math.PI/2 && Math.abs(cornerAngle - checkAngle) % (Math.PI*2) <= Math.PI*3/2){
								check = false;
							}
							cornerAngle = Math.atan((tankCorner[index4][(index5+3)%4].y - tankCorner[index4][index5].y)/(tankCorner[index4][(index5+3)%4].x - tankCorner[index4][index5].x)) + Math.PI/2;
							if(tankCorner[index4][(index5+3)%4].x < tankCorner[index4][index5].x) cornerAngle += Math.PI;
							
							if(Math.abs(cornerAngle - checkAngle) % (Math.PI*2) >= Math.PI/2 && Math.abs(cornerAngle - checkAngle) % (Math.PI*2) <= Math.PI*3/2){
								check = false;
							}
						}
						if(check){collisions[collisions.length] = index4;}
					}
				}
				return collisions;
			}
			function countProjectiles(owner, types){
				var count = 0;
				if(typeof types === "number"){types = [types];}
				for(var index4 = 0;index4 < projectile[owner].length;index4++){
					if(!projectile[owner][index4].dead && types.includes(projectile[owner][index4].type)){
						count++;
					}
				}
				return count;
			}
			function getPlayerAxis(tank){
				return [{x:Math.sin(player[tank].rotation),y:Math.cos(player[tank].rotation)},{x:Math.sin(player[tank].rotation + Math.PI/2),y:Math.cos(player[tank].rotation + Math.PI/2)},{x:Math.sin(player[tank].rotation + Math.PI),y:Math.cos(player[tank].rotation + Math.PI)},{x:Math.sin(player[tank].rotation + Math.PI*3/2),y:Math.cos(player[tank].rotation + Math.PI*3/2)}]
			}
			
			function killPlayers(){
				var kill = false;
				var killTanks = [];
				var index4 = 0;
				var index5 = 0;
				for(index1 = 0;index1 < players;index1++){
					for(index2 = 0;index2 < projectile[index1].length;index2++){
						if(!projectile[index1][index2].dead && !(projectile[index1][index2].type == 9 && projectile[index1][index2].timeLeft < shrapnelFade)){
							kill = false;
							for(index3 = 0;index3 < players;index3++){
								if(!player[index3].dead && distance(projectile[index1][index2].Xpos, projectile[index1][index2].Ypos, player[index3].Xpos, player[index3].Ypos) <= tankScale*Math.sqrt(13) + projectile[index1][index2].size){
									playerAxis = getPlayerAxis(index3);
									for(index4 = 0;index4 < 4;index4++){
										killTanks = playerCollisions(projectile[index1][index2].Xpos + playerAxis[index4].x * projectile[index1][index2].size, projectile[index1][index2].Ypos + playerAxis[index4].y * projectile[index1][index2].size);
										for(index5 = 0;index5 < killTanks.length;index5++){
											kill = true;
											if(projectile[index1][index2].type != 4){
												player[killTanks[index5]].dead = true;
												player[killTanks[index5]].deaths++;
												if(index1 != killTanks[index5]){
													player[index1].kills++;
												}
											}
										}
									}
								}
							}
							if(kill){
								if(projectile[index1][index2].type == 4){
									projectile[index1][index2].timeLeft = Math.min(projectile[index1][index2].timeLeft, mineDelay);
								}
								else if(projectile[index1][index2].type != 2){
									onKill(index1, index2);
									projectile[index1][index2].dead = true;
								}
							}
						}
					}
				}
			}
			function winCheck(){
				var winner = -1;
				for(index1 = 0;index1 < players;index1++){
					if(!player[index1].dead){
						if(winner == -1)winner = index1;
						else winner = -2;
					}
				}
				if(winCountdown < 0 && winner > -2){
					winCountdown = 50*3;
				}
				if(winCountdown == 0 && winner > -1){
					player[winner].score++;
				}
			}
			
			
			function pickUp(tank, target){
				var pickupType = powerUp[target].modifier ? "modifier":"powerUp";
				if(player[tank][pickupType] == 0 && countProjectiles(tank, [2,6]) == 0){
					player[tank][pickupType] = powerUp[target].type;
					powerUp[target].dead = true;
					if(pickupType == "powerUp"){
						if(powerUp[target].type == 3) player[tank].ammo = player[tank].modifier == 3 ? 60:20;
						if(powerUp[target].type == 4) player[tank].ammo = 3;
					}
					if(pickupType == "modifier"){
						if(powerUp[target].type == 3 && player[tank].powerUp == 3){player[tank].ammo *= 3;}
					}
				}
			}
			
			
			function shoot(owner, type = 0, count = 1, spread = 0.1, random = false, special = {speed:1, phase:0}, addBarrel = true, x = player[owner].Xpos, y = player[owner].Ypos, r = player[owner].rotation){
				var index4 = 0;
				var addRotation;
				for(index3 = 0;index3 < projectile[owner].length && index4 < count;index3++){
					shot = projectile[owner][index3];
					if(shot.dead){
						shot.dead = false;
						setProperties(shot, baseProjectile[type]);
						if(!random)addRotation = (index4 - (count-1)/2)*spread;
						else addRotation = (Math.random()-0.5)*spread;
						if(type == 2)shot.speed *= special.speed;
						else shot.speedVector *= special.speed;
						if("rotation" in shot)shot.rotation = r + addRotation;
						shot.Xpos = x + Math.sin(r)*(addBarrel ? 11 + baseProjectile[type].size:0)*(baseProjectile[type].speedVector < 0 ? -1:1);
						shot.Ypos = y + Math.cos(r)*(addBarrel ? 11 + baseProjectile[type].size:0)*(baseProjectile[type].speedVector < 0 ? -1:1);
						shot.Xspeed = Math.sin(r + addRotation)*shot.speedVector;
						shot.Yspeed = Math.cos(r + addRotation)*shot.speedVector;
						shot.phase = special.phase;
						if(type == 9){
							shot.rotation = Math.random() * Math.PI*2;
							shot.rotationSpeed = Math.random() * 0.6 - 0.3;
							shot.corner[0] = Math.random() * Math.PI/6;
							shot.corner[1] = Math.random() * Math.PI/6 + Math.PI*2/3;
							shot.corner[2] = Math.random() * Math.PI/6 + Math.PI*4/3;
						}
						index4++;
					}
				}
			}
			function generateMaze(){
				noIslands = false;
				while(!noIslands){
					maze.width = Math.floor(Math.random()*10)+6;
					maze.height = Math.floor(Math.random()*(maze.width - 6))+6;
					scale = Math.min((canvas.width - 2*border.x)/((maze.width+2) * tileSize),(canvas.height - 2*border.y - scoreArea)/((maze.height+2) * tileSize));
					mazeBorder.x = Math.round((canvas.width - 2*border.x - (maze.width+2) * tileSize * scale)/2);
					mazeBorder.y = Math.round((canvas.height - 2*border.y - (maze.height+2) * tileSize * scale)/2) - scoreArea;
					
					for(index1 = 0;index1 < maze.width + 2;index1++){
						for(index2 = 0;index2 < maze.height + 2;index2++){
							if(index1 % (maze.width + 1) == 0 || index2 % (maze.height + 1) == 0){
								maze[index1][index2].tile = 1;
								maze[index1][index2].leftWall = 0;
								maze[index1][index2].topWall = 0;
							}
							else{
								maze[index1][index2].tile = Math.floor(Math.random()*tileChance);
								maze[index1][index2].leftWall = Math.floor(Math.random()*wallChance);
								maze[index1][index2].topWall = Math.floor(Math.random()*wallChance);
							}
							maze[index1][index2].group = 0;
						}
					}
					stop = false;
					for(index1 = 1;index1 < maze.width + 1 && !stop;index1++){
						for(index2 = 1;index2 < maze.height + 1 && !stop;index2++){
							if(maze[index1][index2].tile == 0){
								maze[index1][index2].group = 1;
								stop = true;
							}
						}
					}
					stop = false;
					while(!stop){
						stop = true;
						for(index1 = 1;index1 < maze.width + 1 && stop;index1++){
							for(index2 = 1;index2 < maze.height + 1 && stop;index2++){
								if(maze[index1][index2].group != maze[index1 + 1][index2].group && maze[index1][index2].tile + maze[index1 + 1][index2].tile == 0){
									maze[index1][index2].group = 1;
									maze[index1 + 1][index2].group = 1;
									stop = false;
								}
								if(maze[index1][index2].group != maze[index1][index2 + 1].group && maze[index1][index2].tile + maze[index1][index2 + 1].tile == 0){
									maze[index1][index2].group = 1;
									maze[index1][index2 + 1].group = 1;
									stop = false;
								}
							}
						}
					}
					stop = false;
					noIslands = true;
					for(index1 = 1;index1 < maze.width + 1 && !stop;index1++){
						for(index2 = 1;index2 < maze.height + 1 && !stop;index2++){
							if(maze[index1][index2].group == 0 && maze[index1][index2].tile == 0){
								noIslands = false;
								stop = true;
							}
						}
					}
				}
				for(index1 = 0;index1 < maze.width + 2;index1++){
					for(index2 = 0;index2 < maze.height + 2;index2++){
						maze[index1][index2].group = 0;
					}
				}
				
				for(index1 = 0;index1 < maze.width + 2;index1++){
					for(index2 = 0;index2 < maze.height + 2;index2++){
						if(maze[index1][index2].tile != maze[index1 + 1][index2].tile){
							maze[index1 + 1][index2].leftWall = 1;
						}
						if(maze[index1][index2].tile != maze[index1][index2 + 1].tile){
							maze[index1][index2 + 1].topWall = 1;
						}
						if(maze[index1][index2].tile + maze[index1 + 1][index2].tile == 2){
							maze[index1 + 1][index2].leftWall = 0;
						}
						if(maze[index1][index2].tile + maze[index1][index2 + 1].tile == 2){
							maze[index1][index2 + 1].topWall = 0;
						}
					}
				}
				stop = false;
				for(index1 = 1;index1 < maze.width + 1 && !stop;index1++){
					for(index2 = 1;index2 < maze.height + 1 && !stop;index2++){
						if(maze[index1][index2].tile == 0){
							maze[index1][index2].group = 1;
							stop = true;
						}
					}
				}
				stop = false;
				while(!stop){
					stop = false;
					while(!stop){
						stop = true;
						for(index1 = 1;index1 < maze.width + 1 && stop;index1++){
							for(index2 = 1;index2 < maze.height + 1 && stop;index2++){
								if(maze[index1][index2].group != maze[index1 + 1][index2].group && maze[index1 + 1][index2].leftWall == 0){
									maze[index1][index2].group = 1;
									maze[index1 + 1][index2].group = 1;
									stop = false;
								}
								if(maze[index1][index2].group != maze[index1][index2 + 1].group && maze[index1][index2 + 1].topWall == 0){
									maze[index1][index2].group = 1;
									maze[index1][index2 + 1].group = 1;
									stop = false;
								}
							}
						}
					}
					index3 = 0;
					groupEdge = [];
					for(index1 = 1;index1 < maze.width + 1;index1++){
						for(index2 = 1;index2 < maze.height + 1;index2++){
							if(maze[index1][index2].group != maze[index1 + 1][index2].group && maze[index1][index2].tile + maze[index1 + 1][index2].tile == 0){
								groupEdge[index3] = [index1 + 1, index2, "leftWall"];
								index3++;
							}
							if(maze[index1][index2].group != maze[index1][index2 + 1].group && maze[index1][index2].tile + maze[index1][index2 + 1].tile == 0){
								groupEdge[index3] = [index1, index2 + 1, "topWall"];
								index3++;
							}
						}
					}
					for(index3 = 0;index3 < groupEdge.length;index3++){
						if(Math.random() < loopChance){
							maze[groupEdge[index3][0]][groupEdge[index3][1]][groupEdge[index3][2]] = 0;
						}
					}
					stop = true;
					for(index1 = 1;index1 < maze.width + 1;index1++){
						for(index2 = 1;index2 < maze.height + 1;index2++){
							if(maze[index1][index2].group + maze[index1][index2].tile == 0){
								stop = false;
							}
						}
					}
				}
				for(index1 = 1;index1 < maze.width;index1++){
					for(index2 = 1;index2 < maze.height;index2++){
						if(maze[index1][index2].tile + maze[index1 + 1][index2].tile + maze[index1][index2 + 1].tile + maze[index1 + 1][index2 + 1].tile == 0
						&& maze[index1 + 1][index2].leftWall + maze[index1][index2 + 1].topWall + maze[index1 + 1][index2 + 1].leftWall + maze[index1 + 1][index2 + 1].topWall == 0){
							index3 = Math.floor(Math.random()*4);
							maze[index1 + squareCenterLine[index3][0]][index2 + squareCenterLine[index3][1]][squareCenterLine[index3][2]] = 1;
						}
					}
				}
				
				//other setup
				for(index3 = 0;index3 < players;index3++){
					var r = 3;
					var i = 0;
					stop = false;
					while(!stop){
						index1 = Math.floor(Math.random()*(maze.width + 1));
						index2 = Math.floor(Math.random()*(maze.height + 1));
						
						if(maze[index1][index2].tile == 0){
							player[index3].Xpos = (index1 + 0.5)*tileSize;
							player[index3].Ypos = (index2 + 0.5)*tileSize;
							player[index3].rotation = Math.random()*Math.PI*2;
							player[index3].dead = false;
							//player[index3].powerUp = 0;
							//player[index3].modifier = 0;
							//player[index3].ammo = 0;
							stop = true;
						}
						for(var index4 = 0;index4 < index3;index4++){
							if(distance(player[index3].Xpos, player[index3].Ypos, player[index4].Xpos, player[index4].Ypos) < tileSize*r){
								stop = false;
							}
						}
						i++;
						if(i > 100){
							i = 0;
							r -= 0.5;
						}
						if(r < 1) stop = true;
					}
				}
				for(index1 = 0;index1 < players;index1++){
					for(index2 = 0;index2 < projectile[index1].length;index2++){
						projectile[index1][index2].dead = true;
					}
				}
				for(index1 = 0;index1 < powerUp.length;index1++){
					powerUp[index1].dead = true;
				}
				
				powerUpCountdown = Math.floor(Math.random()*10 + 5)*50;
			}
			
			
			function inTile(x,y){
				if(y == null){
					if(typeof x === "object"){
						return {x:Math.floor(x.x/tileSize),y:Math.floor(x.y/tileSize)};
					}
					else{
						return Math.floor(x/tileSize);
					}
				}
				else{
					return {x:Math.floor(x/tileSize),y:Math.floor(y/tileSize)};
				}
			}
			function isEquivalent(a, b) {
				var aProps = Object.getOwnPropertyNames(a);
				var bProps = Object.getOwnPropertyNames(b);
				if (aProps.length != bProps.length) {
					return false;
				}
				
				for (var i = 0; i < aProps.length; i++) {
					var propName = aProps[i];
					if (a[propName] !== b[propName]) {
						return false;
					}
				}
				return true;
			}
			function setProperties(a, b){
				var bProps = Object.getOwnPropertyNames(b);
				for (var i = 0; i < bProps.length; i++){
					a[bProps[i]] = b[bProps[i]];
				}
			}
			
			function distance(x1, y1, x2, y2){
				return Math.sqrt((x1 - x2)*(x1 - x2) + (y1 - y2)*(y1 - y2));
			}
			function mazePath(){}
			
			/*
			addEventListener('mousemove', onMove, false);
			function onMove(evt){
				//mouse = getMousePos(canvas, evt);
			}
			document.addEventListener("click", onClick);
			function onClick(){
				
			}
			*/
			window.oncontextmenu = function(){return false;}
			
			
			document.addEventListener("keydown", keyDownHandler, false);
			document.addEventListener("keyup", keyUpHandler, false);
			function keyDownHandler(e) {
				for(index1 = 0;index1 < players && index1 < controls.length;index1++){
					for(index2 = 0;index2 < 4;index2++){
						if(e.key == controls[index1][index2]){
							player[index1][directionCode[index2]] = true;
							event.preventDefault();
						}
					}
					if(e.key == controls[index1][4]){
						if(player[index1].shooting == 0){
							player[index1].shooting = 2;
						}
					}
				}
			}
			function keyUpHandler(e) {
				for(index1 = 0;index1 < players && index1 < controls.length;index1++){
					for(index2 = 0;index2 < 4;index2++){
						if(e.key == controls[index1][index2]){
							player[index1][directionCode[index2]] = false;
							event.preventDefault();
						}
					}
					if(e.key == controls[index1][4]){
						player[index1].shooting = 0;
					}
				}
			}
			
			
			
			
			
			initializeArrays();
			generateMaze();
			
			
			
			
			function draw(event) {     //=========================================================================================================================================================================================================
				
				if(frezeCountdown <= 0){
					ctx.clearRect(0, 0, canvas.width, canvas.height);


					drawMaze();
					drawPowerups();

					movePlayers();
					moveProjectiles();

					killPlayers();

					drawProjectiles();
					drawTanks();
					drawScores();
					
					winCheck();
					
					if(powerUpCountdown == 0){
						powerUpCountdown = Math.floor(Math.random()*10 + 5)*50;
						spawnPickup();
					}
					powerUpCountdown--;
				}
				else frezeCountdown--;
					
				
				if(frezeCountdown == 1) generateMaze();
				if(winCountdown == 0) frezeCountdown = 50;
				if(winCountdown >= 0) winCountdown--;
				
				
				
				
				
				setTimeout(draw, 20);
			}
			draw();
			
		</SCRIPT>
	</body>
</html>
