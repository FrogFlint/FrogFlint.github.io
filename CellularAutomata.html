<!DOCTYPE html>
<html lang="en" dir="ltr">
	<head>

		<meta charset="utf-8">
		<title>Custom Cellular Automaton Creator</title>

		<style>
			body {
				background: #303030;
			}
			body > div {
				position: absolute;
				width: 100%;
				height: 100%;
				left: 0%;
				top: 0%;
			}
			.sidebar {
				position: absolute;
				right: 0%;
				top: 0%;
				height: 100%;

				background: #151515;
				border-left: 1px solid white;
				box-sizing: border-box;
			}

			#cellTypes {
				position: absolute;
				left: 0%;
				top: 0%;
				width: 75%;
				height: 100%;
			}
			#design .sidebar {
				width: 25%;
				padding: 2%;
			}
			#cellTypeName {
				color: white;
				font-size: 20px;
			}
			#rules {
				position: absolute;
				width: 80%;
				top: 20%;
			}
			#rules > div {
				display: flex;
				width: 100%;
				height: 30px;
				border: 1px solid gray;
				background: #202020;
			}
			#rules > div > div:first-child {
				width: 30px;
				height: 30px;
				border-right: 1px solid gray;
			}
			#rules > div > div:last-child {
				width: calc(100% - 30px);
				height: 30px;
				right: 0%;
				color: white;
				font-size: 20px;
			}
			#buttons {
				position: absolute;
				bottom: 5%;
			}

			#run .sidebar {
				width: 20%;
			}
			#controls {
				color: white;
				padding: 4%;
			}
			#controls * {
				margin-right: 4%;
			}
			#selectCellType {
				padding: 8%;
				display: flow-root;
			}
			#selectCellType div {
				width: 50px;
				height: 50px;
				margin: 8%;
				border: 1px solid white;
			}
			#grid-container {
				position: relative;
				overflow: hidden;
				width: 80%;
				height: 100%;

				user-select: none;
			}
			#grid {
				position: absolute;
				left: 0%;
				top: 0%;
			}
			.gridRow {
				display: flex;
				position: absolute;
				left: 0px;
			}
			.cell {
				box-sizing: border-box;

				position: absolute;
				top: 0px;
			}
		</style>

		<style id="cellSize">
			.cell {
				width: 50px;
				height: 50px;
			}
		</style>
		<style id="cellBorders">
			.cell {
				border: 1px solid #303030;
			}
		</style>
		<style id="cellColors">
			.cellType-0 { background: #101010; }
			.cellType-1 { background: gold; }
		</style>

	</head>
	<body>

		<div id="design">
			<svg id="cellTypes"></svg>
			<div class="sidebar">
				<div id="cellTypeName" oninput="cellTypes[selectedCellType].name = cellTypeOptions.children[0].innerText" contenteditable></div>
				<div id="cellTypeColor"><input type="color"></input></div>
				<div id="rules"></div>
				<div id="buttons">
					<button onclick="newCellType()">New cell type</button>
					<button onclick="deleteCellType(selectedCellType)">Delete cell type</button>
					<br><br><button onclick="resetGrid()">Start simulation</button>
				</div>
			</div>
		</div>
		<div id="run" style="display: none">
			<div id="grid-container">
				<div id="grid"></div>
			</div>
			<div class="sidebar">
				<div id="controls">
					<button onclick="controlFunctions[0]()">Play</button>
					<button onclick="if(paused)timeStep()">Step</button>
					<span id="stepCounter">0 iterations</span>
					<br><input type="range" min=1 max=100 onchange="controlFunctions[1]()">Play speed</input>
					<br><input type="checkbox" checked=true onchange="controlFunctions[2]()">Show grid</input>
					<br><input type="checkbox" onchange="controlFunctions[3]()">Show empty grid</input>
					<br><br><button onclick="setView('design')">Edit rules</button>
				</div>
				<div id="selectCellType"></div>
			</div>
		</div>

		<script>
			let gridContainer = document.getElementById("grid-container");  ///  HTML elements
			let gridDisplay = document.getElementById("grid");
			let cellColorsCSS = document.getElementById("cellColors");
			let cellSizeCSS = document.getElementById("cellSize");
			let cellBordersCSS = document.getElementById("cellBorders");
			let controls = document.getElementById("controls");
			let cellTypeSelector = document.getElementById("selectCellType");
			let cellTypeOptions = document.querySelector("#design .sidebar");
			let cellTypeRules = cellTypeOptions.children[2];
			let cellTypeSVG = document.getElementById("cellTypes");

			let cellSize = 50;  //px
			let displayWidth = 20;
			let displayHeight = 10;

			let view = "design";
			let showGrid = false;
			let showCellBorders = true;

			let cellTypes = [];  ///  design
			//let selectedCell = 0;   //uses the same variable selectedCellType
			//let selectedConnection = -1;

			let grid = [[]]; ///  run
			let countGrid = [[[]]];
			let time = 0;
			let paused = true;
			let speed = 100;  //ms per frame
			let selectedCellType = -1;
			let mouse = {left:false, right:false, shift:false, x:0, y:0, dx:0, dy:0};
			let camera = {x:0, y:0, zoom:1, zoomF:1.0};


			class CellType{
				constructor(){
					this.color = "#202020";
					this.name = "new cell type";
					this.id = cellTypes.length;
					this.rules = range(this.id + 1).map(i => new CellRule);
					this.rulePriority = range(this.id + 1);

					this.x = cellTypeSVG.clientWidth/2;
					this.y = cellTypeSVG.clientHeight/2;
				}
				nextType(totals){
					for(let i of this.rulePriority)
						if(this.rules[i].check(...totals))
							return i;
					return this.id;
				}
			}
			class CellRule{
				constructor(){
					this.text = "";
					this.check = () => false;
				}
				parse(){
					if(this.text == ""){
						this.check = () => false;
						return;
					}
					let clauses = multiSplit(this.text, ["|","&","=",",","-","+",/f*(?=\.)/]);
					eval("this.check = (...args) => " + multiJoin(
						clauses,
						[
							"||",
							"&&",
							"&",
							s => s.search(/[^|]\|[^|]/) == -1 ? s : "("+s+")",
							"|",
							a => a.length > 1 ? "Math.max(2*("+(a[1] || bit[8])+")-("+(a[0] || bit[0])+"),0)" : a[0],
							false,
							s => s ? s.match(/^args\[\d+]$/) ? "bit["+s+"]" : "(bit["+s+"]||0)" : s,
							"+",
							"*",
							n => n[0] == "." ? "args["+n.slice(1)+"]" : n
						].map(x => x ? [preEvaluate, x] : x).flat()
					));
				}
			}
			const bit = [1, 2, 4, 8, 16, 32, 64, 128, 256];
			const preEvaluate = str => {
				if(str.search("args") == -1 && str){
					let r = "";
					eval("r = " + str + ";");
					return r + "";
				}
				return str;
			}


			function newCellType(){
				typeNumber = cellTypes.length;

				cellTypes.forEach(type => {
					type.rules.push(new CellRule());
					type.rulePriority.push(typeNumber);
				});
				cellTypes.push(new CellType());

				cellTypeSVG.innerHTML +=
					"<circle id='cellType-" + typeNumber +
					"' r=25 cx=" + cellTypeSVG.clientWidth/2 +
					" cy=" + cellTypeSVG.clientHeight/2 +
					" fill='#202020' stroke='black' stroke-width=2></circle>";
				editCellType(typeNumber);
			}
			function deleteCellType(type){
				//
				cellTypes.slice(type, 1);
			}
			function editCellType(type){
				if(selectedCellType >= 0)
					cellTypeCircle(selectedCellType).setAttribute("stroke", "black");
				selectedCellType = type;
				if(type < 0)
					return;
				cellTypeCircle(type).setAttribute("stroke", "white");
				cellTypeCircle(type).setAttribute("fill", cellTypes[type].color);

				cellTypeOptions.children[0].innerText = cellTypes[type].name;
				cellTypeOptions.children[1].firstChild.value = cellTypes[type].color;
				cellTypeOptions.children[1].firstChild.oninput = () => {
					cellTypes[type].color = cellTypeOptions.children[1].firstChild.value;
					editCellType(type);
				};
				cellTypeRules.innerHTML = cellTypes[type].rules.map(
					(rule, i) =>
					"<div><div style='width: 30px; height: 30px; background: " +
					cellTypes[i].color +
					"'></div><div contenteditable></div></div>"
				).join("");
				Array.from(cellTypeRules.children).forEach((el, i) => {
					el.lastChild.innerText = cellTypes[type].rules[i].text;
					el.lastChild.oninput = () => cellTypes[type].rules[i].text = el.innerText;
				});
			}
			const cellTypeCircle = type => document.getElementById("cellType-" + type);


			function setView(id){
				document.getElementById(view).style.display = "none";
				document.getElementById( id ).style.display = "";
				view = id;
			}
			function selectCellType(type){
				selectedCellType = type;
				Array.from(cellTypeSelector.children).forEach((el, i) => el.style.borderColor = i == type ? "#E0E0E0" : "#080808");
			}
			function createDisplayGrid(){
				if(showGrid){
					gridDisplay.innerHTML = range(displayHeight + 1).map(
						j =>
						"<div class='gridRow'>\n" +
						range(displayWidth + 1).map(
							i =>
							"<div class='cell cellType-" +
							(grid[i - Math.floor(camera.x)] ? grid[i - Math.floor(camera.x)][j - Math.floor(camera.y)] || 0 : 0) +
							"'></div>"
						).join("\n") + "\n</div>"
					).join("\n");
				}
				else{
					gridDisplay.innerHTML = range(displayHeight + 1).map(
						j =>
						range(displayWidth + 1).map(
							i =>
							grid[i - Math.floor(camera.x)] && grid[i - Math.floor(camera.x)][j - Math.floor(camera.y)]
							?	"<div class='cell cellType-" +
								(grid[i - Math.floor(camera.x)][j - Math.floor(camera.y)] || 0) +
								"' style='left:" + i*cellSize + "px;top:" + j*cellSize + "px'></div>"
							:	""
						).join("\n")
					).join("\n");
				}

				moveDisplayGrid();
			}
			function moveDisplayGrid(forceDraw = false){
				gridDisplay.style.left = Math.round((mod(camera.x, 1) - 1)*cellSize) + "px";
				gridDisplay.style.top =  Math.round((mod(camera.y, 1) - 1)*cellSize) + "px";

				cellSizeCSS.innerHTML = ".cell{ width: " + cellSize + "px; height: " + cellSize + "px; }";

				if(showGrid){
					let dx = Math.floor(camera.x) - Math.floor(camera.x - mouse.dx/cellSize);
					let dy = Math.floor(camera.y) - Math.floor(camera.y - mouse.dy/cellSize);
					let x, y;
					if(!(dx == 0 && dy == 0) || forceDraw)
						for(let i in grid)
							if(inRange(x = +i + Math.floor(camera.x), 0, displayWidth) || inRange(x - dx, 0, displayWidth))
								for(let j in grid[i])
									if(inRange(y = +j + Math.floor(camera.y), 0, displayHeight) || inRange(y - dy, 0, displayHeight)){
										if(inRange(x, 0, displayWidth) && inRange(y, 0, displayHeight))
											setDisplayCell(x, y, grid[i][j]);
										if(inRange(x - dx, 0, displayWidth) && inRange(y - dy, 0, displayHeight))
											setDisplayCell(x - dx, y - dy, grid[i - dx] ? grid[i - dx][j - dy] || 0 : 0);
									}
				}
			}
			function setDisplayCell(x, y, type){
				gridDisplay.children[y].children[x].classList = "cell cellType-" + type;
			}

			function zoomUpdate(){
				cellSize = Math.round(50 / (1.2 ** camera.zoom));
				displayWidth = Math.ceil(gridContainer.clientWidth / cellSize);
				displayHeight = Math.ceil(gridContainer.clientHeight / cellSize);
			}
			function timeStep(){
				countGrid = [];
				for(let i in grid)
					for(let j in grid[i]){
						for(let x of [i - 1, i, +i + 1]){
							if(!(x in countGrid))
								countGrid[x] = [];
							for(let y of [j - 1, j, +j + 1]){
								if(!(y in countGrid[x]))
									countGrid[x][y] = [0, 8].concat(new Array(cellTypes.length - 1).fill(0));
								if(!(x == i && y == j)){
									countGrid[x][y][grid[i][j] + 1]++;
									countGrid[x][y][1]--;
								}
							}
						}
						countGrid[i][j][0] = grid[i][j];
					}

				grid = [];
				for(let i in countGrid)
					for(let j in countGrid[i]){
						let type = cellTypes[countGrid[i][j][0]].nextType(countGrid[i][j].slice(1));
						if(type){
							if(!(i in grid))
								grid[i] = [];
							grid[i][j] = type;
						}
					}
				if(!showGrid)
					createDisplayGrid();

				if(view == "run" && !paused)
					setTimeout(timeStep, speed);

				controls.children[2].innerText = ++time + " iterations";
			}
			function resetGrid(){
				grid = [];
				countGrid = [];
				time = 0;
				paused = true;
				selectedCellType = 0; //temp
				mouse = {left:false, right:false, x:0, y:0, dx:0, dy:0};
				camera = {x:0, y:0, zoom:2, zoomF:2.0};

				setView("run");
				zoomUpdate();
				createDisplayGrid();

				cellTypeSelector.innerHTML = cellTypes.map((type, i) => "<div style='background:" + type.color + "' onclick='selectCellType(" + i + ")'></div>").join("");
				selectCellType(1);
				controls.children[0].innerText = "Play";
				controls.children[2].innerText = "0 iterations";

				gridContainer.style.background = cellTypes[0].color;
				cellColorsCSS.innerHTML = cellTypes.map((type, i) => ".cellType-" + i + "{background:" + type.color + ";}").join("\n");
				cellTypes.forEach(type => type.rules.forEach(rule => rule.parse()));
			}

			function rowIsEmpty(x){
				for(let i in grid[x])
					return false;
				return true;
			}


			const range = (max, min = 0) => new Array(max - min).fill(0).map((x,i) => i + min);
			const inRange = (val, min, max) => min <= val && val <= max;
			const mod = (num, base) => num - Math.floor(num / base) * base;
			const multiSplit = (str, delims) => delims.length ? str.split(delims[0]).map(sub => multiSplit(sub, delims.slice(1))) : str;
			const multiJoin = (arr, opers) => {
				if(!opers.length) return arr;
				if(typeof opers[0] == "function")
					return opers[0](multiJoin(arr, opers.slice(1)));
				arr = arr.map(x => multiJoin(x, opers.slice(1)));
				return opers[0] === false ? arr : arr.join(opers[0]);
			}
			document.oncontextmenu = () => false;

			let mouseEventHandlers = [
				["mousedown", evt => {
					if(evt.button == 0) mouse.left  = true;
					if(evt.button == 2) mouse.right = true;

					onMouseEvent(evt);
				}],
				["mouseup", evt => {
					if(evt.button == 0) mouse.left  = false;
					if(evt.button == 2) mouse.right = false;

					onMouseEvent(evt);
				}],
				["mousemove", onMouseEvent]
			];
			for(let el of [gridContainer, cellTypeSVG])
				for(let [eventType, handler] of mouseEventHandlers)
					el.addEventListener(eventType, handler);
			gridContainer.addEventListener("wheel", evt => {
				camera.zoomF = Math.max(Math.min(camera.zoomF - evt.wheelDelta/150, 15), 0);
				camera.zoom = Math.round(camera.zoomF);

				camera.x -= mouse.x/cellSize;
				camera.y -= mouse.y/cellSize;
				zoomUpdate();
				camera.x += mouse.x/cellSize;
				camera.y += mouse.y/cellSize;

				createDisplayGrid();
			});
			document.addEventListener("keydown", evt => {
				if(view == "run"){
					if(evt.keyCode == 32) controlFunctions[0]();
					else if(evt.key == "s" && paused) timeStep();
					else if(evt.key == "escape") setView("design");
					else if((evt.key - 1) in cellTypes) selectCellType(evt.key - 1);
				}
			});

			function onMouseEvent(evt){
				mouse.dx = evt.clientX - mouse.x;
				mouse.dy = evt.clientY - mouse.y;
				mouse.x = evt.clientX;
				mouse.y = evt.clientY;
				mouse.shift = evt.shiftKey;

				if(view == "run"){
					if(mouse.right){
						camera.x += mouse.dx / cellSize;
						camera.y += mouse.dy / cellSize;
						camera.xc = Math.floor(camera.x);
						camera.yc = Math.floor(camera.y);
					}

					let x = Math.floor(mouse.x / cellSize - camera.x) + 1;  //+1 is for buffer cells that are partially cut off
					let y = Math.floor(mouse.y / cellSize - camera.y) + 1;

					if(mouse.left){
						if(selectedCellType == 0){
							if(x in grid){
								delete grid[x][y];
								if(rowIsEmpty(x))
									delete grid[x];
							}
						}
						else{
							if(!grid[x])
								grid[x] = [];
							grid[x][y] = selectedCellType;
						}
					}

					if(!showGrid)
						createDisplayGrid();
					else if(mouse.right)
						moveDisplayGrid();
					else if(mouse.left)
						setDisplayCell(x + Math.floor(camera.x), y + Math.floor(camera.y), selectedCellType);
				}
				else{
					let closest = -1, d = 25;
					for(let i in cellTypes){
						let dist = Math.sqrt((mouse.x - mouse.dx - cellTypes[i].x)**2 + (mouse.y - mouse.dy - cellTypes[i].y)**2);
						if(dist <= 25 && dist <= d){
							closest = Number(i);
							d = dist;
						}
					}

					if(closest >= 0){
						let circle = cellTypeCircle(closest);
						if(mouse.right){
							cellTypes[closest].x += mouse.dx;
							cellTypes[closest].y += mouse.dy;
							circle.setAttribute("cx", cellTypes[closest].x);
							circle.setAttribute("cy", cellTypes[closest].y);
						}
						else if(mouse.left){
							if(mouse.shift){ }
							else{
								editCellType(closest);
							}
						}
					}
					else if(mouse.left)
						editCellType(-1);
				}
			}



			let controlFunctions = [
				() => {
					paused = !paused;
					if(!paused) timeStep();
					controls.children[0].innerText = paused ? "Play" : "Stop";
				},
				() => speed = 1000 / controls.children[4].value,
				() => {
					showCellBorders = !showCellBorders;
					cellBordersCSS.innerHTML = showCellBorders ? ".cell{border:1px solid #303030}" : "";
				},
				() => {
					showGrid = !showGrid;
					createDisplayGrid();
				}
			];

			//  temp setup
			for(let i = 0; i < 0; i++){
				let row = Math.floor(Math.random()*displayWidth);
				if(!grid[row]) grid[row] = [];
				grid[row][Math.floor(Math.random()*displayHeight)] = 1;
			}

			newCellType();
			newCellType();
			cellTypes[0].x = 300;
			cellTypes[1].color = "#FFD700";  //gold
			cellTypeCircle(0).setAttribute("cx", "300");
			cellTypeCircle(1).setAttribute("fill", "gold");
			cellTypes[0].rules[1].text = ".1=3";
			cellTypes[1].rules[0].text = ".1=-1,4-";
			editCellType(1);
			

		</script>

	</body>
</html>
