<!DOCTYPE html>
<html lang="en" dir="ltr">
	<head>

		<meta charset="utf-8">
		<title>Custom Cellular Automaton Creator</title>

		<style>
			body {
				background: #303030;
			}
			body > div {
				position: absolute;
				width: 100%;
				height: 100%;
				left: 0%;
				top: 0%;
			}
			.sidebar {
				position: absolute;
				right: 0%;
				top: 0%;
				height: 100%;

				background: #151515;
				border-left: 1px solid white;
				box-sizing: border-box;
			}

			#cellTypes {
				position: absolute;
				left: 0%;
				top: 0%;
				width: 75%;
				height: 100%;
			}
			#design .sidebar {
				width: 25%;
				padding: 2%;
				display: flex;
			}
			#cellTypeName {
				color: white;
				font-size: 20px;
				padding: 5px;
				height: fit-content;
				outline: none;
				border-radius: 2px;
			}
			#cellTypeColor {
				position: absolute;
				right: 10%;
			}
			#rules {
				position: absolute;
				width: 80%;
				top: 20%;
				max-height: 349px;
				overflow-x: hidden;
				overflow-y: scroll;
				border: 1px solid gray;
				/*box-sizing: border-box;*/
			}
			#rules > div {
				display: flex;
				position: relative;
				width: calc(100% + 2px);
				height: 30px;

				border: 1px solid gray;
				margin: -1px;
				margin-bottom: 0px;

				background: #202020;
				box-sizing: border-box;
			}
			#rules > div:last-child {
				margin-bottom: -1px;
			}
			#rules > div > div:first-child {
				width: 28px;
				height: 28px;
				margin-top: 0px;
				border-right: 1px solid gray;
				box-sizing: border-box;
			}
			#rules > div > div:last-child {
				width: calc(100% - 30px);
				height: 30px;
				right: 0%;
				color: white;
				font-size: 20px;
			}
			::-webkit-scrollbar {
				display: none;
			}
			#textSave {
				position: absolute;
				top: 75%;
				color: white;
			}
			#textSave input {
				margin-top: 3px;
				padding: 2px;
				color: white;
				background: #303030;
				border: 1px solid grey;
				outline: none;
			}
			#buttons {
				position: absolute;
				bottom: 5%;
			}

			#run .sidebar {
				width: 20%;
			}
			#controls {
				color: white;
				padding: 4%;
			}
			#controls * {
				margin-right: 4%;
			}
			#selectCellType {
				padding: 8%;
				display: flow-root;
			}
			#selectCellType div {
				width: 50px;
				height: 50px;
				margin: 8%;
				border: 1px solid white;
			}
			#grid {
				position: relative;
				/*overflow: hidden;*/
				width: 80%;
				height: 100%;

				user-select: none;
			}
			/*#grid {
				position: absolute;
				left: 0%;
				top: 0%;
			}
			.gridRow {
				display: flex;
				position: absolute;
				left: 0px;
			}
			.cell {
				box-sizing: border-box;

				position: absolute;
				top: 0px;
			}*/
		</style>

		<style id="nameUnderlineColor">
			#cellTypeName:focus {
				border-bottom: 2px groove lime;
			}
		</style>

	</head>
	<body>

		<div id="design">
			<svg id="cellTypes"></svg>
			<div class="sidebar">
				<div id="cellTypeName" oninput="cellTypes[selectedCellType].name = cellTypeOptions.children[0].innerText" contenteditable></div>
				<div id="cellTypeColor"><input type="color"></input></div>
				<div id="rules"></div>
				<div id="textSave">
					Import/export as text<br>
					<input type="text" onfocus="saveDesignAsText()" oninput="loadDesignFromText(textSaveBox.value)" onblur="textSaveBox.value=''"></input>
				</div>
				<div id="buttons">
					<button onclick="newCellType()">New cell type</button>
					<button onclick="deleteCellType(selectedCellType)">Delete cell type</button>
					<br><br><button onclick="resetGrid()">Start simulation</button>
				</div>
			</div>
		</div>
		<div id="run" style="display: none">
			<canvas id="grid"></canvas>
			<div class="sidebar">
				<div id="controls">
					<button onclick="controlFunctions[0]()">Play</button>
					<button onclick="if(paused)timeStep()">Step</button>
					<span id="stepCounter">0 iterations</span>
					<br><input type="range" min=1 max=100 onchange="controlFunctions[1]()">Play speed</input>
					<br><input type="checkbox" checked=true onchange="controlFunctions[2]()">Show grid</input>
					<br><input type="checkbox" onchange="controlFunctions[3]()">Show empty grid</input>
					<br><br><button onclick="setView('design')">Edit rules</button>
				</div>
				<div id="selectCellType"></div>
			</div>
		</div>

		<script>
			//let gridContainer = document.getElementById("grid-container");
			let gridDisplay = document.getElementById("grid");  ///  HTML elements
			let ctx = gridDisplay.getContext("2d");
			//let cellColorsCSS = document.getElementById("cellColors");
			//let cellSizeCSS = document.getElementById("cellSize");
			//let cellBordersCSS = document.getElementById("cellBorders");
			let controls = document.getElementById("controls");
			let cellTypeSelector = document.getElementById("selectCellType");
			let cellTypeOptions = document.querySelector("#design .sidebar");
			let cellTypeRules = document.getElementById("rules");
			let cellTypeSVG = document.getElementById("cellTypes");
			let textSaveBox = document.querySelector("#textSave input");

			let cellSize = 50;  //px
			let displayWidth = 20;
			let displayHeight = 10;

			let view = "design";
			let showGrid = false;
			let showCellBorders = true;

			let cellTypes = [];  ///  design
			//let selectedCell = 0;   //uses the same variable selectedCellType
			//let selectedConnection = -1;

			let grid = [[]]; ///  run
			let countGrid = [[[]]];
			let time = 0;
			let paused = true;
			let speed = 100;  //ms per frame
			let selectedCellType = -1;

			let mouse = {left:false, right:false, shift:false, x:0, y:0, dx:0, dy:0};
			let camera = {x:0, y:0, zoom:1, zoomF:1.0};
			let draggingRule = -1;
			let draggingRuleY = 0;

			class CellType{
				constructor(
					name = "new cell type",
					color = "#202020",
					priority = range(+cellTypes.length + 1),
					rules = new Array(+cellTypes.length + 1).fill(""),
					x = 1/2,
					y = 1/2
				){
					this.name = name;
					this.color = color;
					this.id = cellTypes.length;
					this.rulePriority = priority;
					this.rules = rules.map(text => new CellRule(text));

					this.x = x * cellTypeSVG.clientWidth;
					this.y = y * cellTypeSVG.clientHeight;
				}
				nextType(totals){
					for(let i of this.rulePriority)
						if(this.rules[i].check(...totals))
							return i;
					return this.id;
				}
			}
			class CellRule{
				constructor(text = ""){
					this.text = text;
					//this.check = () => false;
					this.parse();
				}
				parse(){
					this.text = this.text.filter(/[&|\d.+=,-]/g);

					if(this.text == ""){
						this.check = () => false;
						return;
					}

					let clauses = multiSplit(this.text, ["|","&","=",",","-","+",/(?=\.)/]);  //change to lookahead (?>=
					eval("this.check = (...args) => " + multiJoin(
						clauses,  //maybe just define clauses here
						[
							"||",
							"&&",
							"&",
							s => s.search(/[^|]\|[^|]/) == -1 ? s : "("+s+")",
							"|",
							a => a.length > 1 ? "Math.max(2*("+(a[1] || bit[8])+")-("+(a[0] || bit[0])+"),0)" : a[0],
							false,
							s => s ? s.match(/^args\[\d+]$/) ? "bit["+s+"]" : "(bit["+s+"]||0)" : s,
							"+",
							"*",
							n => n[0] == "." ? "args["+n.slice(1)+"]" : n
						].map(x => x ? [preEvaluate, x] : x).flat()
					) + ";");
				}
			}
			const bit = [1, 2, 4, 8, 16, 32, 64, 128, 256];
			const preEvaluate = str => {
				if(str.search("args") == -1 && str){
					let r = "";
					eval("r = " + str + ";");
					return r + "";
				}
				return str;
			}


			function newCellType(){
				typeNumber = cellTypes.length;

				cellTypes.forEach(type => {
					type.rules.push(new CellRule());
					type.rulePriority.push(typeNumber);
				});
				cellTypes.push(new CellType());

				cellTypeSVG.innerHTML +=
					"<circle id='cellType-" + typeNumber +
					"' r=25 cx=" + cellTypeSVG.clientWidth/2 +
					" cy=" + cellTypeSVG.clientHeight/2 +
					" fill='#202020' stroke='black' stroke-width=2></circle>";
				editCellType(typeNumber);
			}
			function deleteCellType(type){
				//
				cellTypes.slice(type, 1);
			}
			function editCellType(type){
				selectedCellType = type;
				for(let i in cellTypes)
					cellTypeCircle(i).setAttribute("stroke", i == type ? "white" : "black");
				if(type < 0)
					return;
				cellTypeCircle(type).setAttribute("fill", cellTypes[type].color);

				cellTypeOptions.children[0].innerText = cellTypes[type].name;
				cellTypeOptions.children[1].firstChild.value = cellTypes[type].color;
				cellTypeOptions.children[1].firstChild.oninput = () => {
					cellTypes[type].color = cellTypeOptions.children[1].firstChild.value;
					editCellType(type);
				};
				cellTypeRules.innerHTML = cellTypes[type].rulePriority.map(
					i =>
					"<div style='transform:translate(0px,0px)'><div style='background: " +
					cellTypes[i].color +
					"'></div><div contenteditable></div></div>"
				).join("");
				Array.from(cellTypeRules.children).forEach((el, i) => {
					el.lastChild.innerText = cellTypes[type].rules[cellTypes[type].rulePriority[i]].text;
					el.lastChild.oninput = () => cellTypes[type].rules[cellTypes[type].rulePriority[Array.from(cellTypeRules.children).indexOf(el)]].text = el.innerText;

					el.onmousedown = evt => {
						if(evt.button == 2){
							draggingRule = Array.from(cellTypeRules.children).indexOf(el);
							draggingRuleY = evt.offsetY;
						}
					}

				});
			}
			function redrawCellTypes(){
				cellTypeSVG.innerHTML = cellTypes.map((type, i) =>
					"<circle id='cellType-" + i +
					"' r=25 cx=" + type.x +
					" cy=" + type.y +
					" fill='" + type.color +
					"' stroke='black' stroke-width=2></circle>"
				).join("");
			}
			const cellTypeCircle = type => document.getElementById("cellType-" + type);
			const cellTypeArrow = (from, to) => document.getElementById("cellType-" + from + "-" + to);


			function setView(id){
				document.getElementById(view).style.display = "none";
				document.getElementById( id ).style.display = "";
				view = id;
			}
			function selectCellType(type){
				selectedCellType = type;
				Array.from(cellTypeSelector.children).forEach((el, i) => el.style.borderColor = i == type ? "#E0E0E0" : "#080808");
			}
			function drawGrid(){
				ctx.clearRect(0, 0, gridDisplay.width, gridDisplay.height);
				for(let i in grid)
					if(i >= camera.x - 1 && i <= camera.x + displayWidth)
						for(let j in grid[i])
							if(j >= camera.y - 1 && j <= camera.y + displayWidth){
								ctx.beginPath();
								ctx.fillStyle = cellTypes[grid[i][j]].color;
								ctx.fillRect(
									Math.round((i - camera.x)*cellSize),
									Math.round((j - camera.y)*cellSize),
									Math.round((i - camera.x + 1)*cellSize) - Math.round((i - camera.x)*cellSize),
									Math.round((j - camera.y + 1)*cellSize) - Math.round((j - camera.y)*cellSize)
								);
								ctx.closePath();
							}

			}

			/*function createDisplayGrid(){//
				if(showGrid){
					gridDisplay.innerHTML = range(displayHeight + 1).map(
						j =>
						"<div class='gridRow'>\n" +
						range(displayWidth + 1).map(
							i =>
							"<div class='cell cellType-" +
							(grid[i - Math.floor(camera.x)] ? grid[i - Math.floor(camera.x)][j - Math.floor(camera.y)] || 0 : 0) +
							"'></div>"
						).join("\n") + "\n</div>"
					).join("\n");
				}
				else{
					gridDisplay.innerHTML = range(displayHeight + 1).map(
						j =>
						range(displayWidth + 1).map(
							i =>
							grid[i - Math.floor(camera.x)] && grid[i - Math.floor(camera.x)][j - Math.floor(camera.y)]
							?	"<div class='cell cellType-" +
								(grid[i - Math.floor(camera.x)][j - Math.floor(camera.y)] || 0) +
								"' style='left:" + i*cellSize + "px;top:" + j*cellSize + "px'></div>"
							:	""
						).join("\n")
					).join("\n");
				}

				moveDisplayGrid();
			}
			function moveDisplayGrid(forceDraw = false){//
				gridDisplay.style.left = Math.round((mod(camera.x, 1) - 1)*cellSize) + "px";
				gridDisplay.style.top =  Math.round((mod(camera.y, 1) - 1)*cellSize) + "px";

				cellSizeCSS.innerHTML = ".cell{ width: " + cellSize + "px; height: " + cellSize + "px; }";

				if(showGrid){
					let dx = Math.floor(camera.x) - Math.floor(camera.x - mouse.dx/cellSize);
					let dy = Math.floor(camera.y) - Math.floor(camera.y - mouse.dy/cellSize);
					let x, y;
					if(!(dx == 0 && dy == 0) || forceDraw)
						for(let i in grid)
							if(inRange(x = +i + Math.floor(camera.x), 0, displayWidth) || inRange(x - dx, 0, displayWidth))
								for(let j in grid[i])
									if(inRange(y = +j + Math.floor(camera.y), 0, displayHeight) || inRange(y - dy, 0, displayHeight)){
										if(inRange(x, 0, displayWidth) && inRange(y, 0, displayHeight))
											setDisplayCell(x, y, grid[i][j]);
										if(inRange(x - dx, 0, displayWidth) && inRange(y - dy, 0, displayHeight))
											setDisplayCell(x - dx, y - dy, grid[i - dx] ? grid[i - dx][j - dy] || 0 : 0);
									}
				}
			}
			function setDisplayCell(x, y, type){//
				gridDisplay.children[y].children[x].classList = "cell cellType-" + type;
			}
			*/
			function zoomUpdate(){
				cellSize = /*Math.round*/(50 / (1.2 ** camera.zoom));
				displayWidth = Math.ceil(gridDisplay.clientWidth / cellSize);
				displayHeight = Math.ceil(gridDisplay.clientHeight / cellSize);
			}

			function timeStep(){
				let emptyCount = new Array(cellTypes.length + 1).fill(0);
				emptyCount[1] = 8;

				//store array of which cells were changed last round

				countGrid = [];
				for(let i in grid)
					for(let j in grid[i]){
						for(let x of [i - 1, i, +i + 1]){
							if(!(x in countGrid))
								countGrid[x] = [];
							let row = countGrid[x];
							for(let y of [j - 1, j, +j + 1]){
								if(!(y in row)){
									row[y] = emptyCount.slice(0);
								}
								let cell = row[y];
								if(!(x == i && y == j)){
									++cell[grid[i][j] + 1];
									--cell[1];
								}
							}
						}
						countGrid[i][j][0] = grid[i][j];
					}

				grid = [];
				for(let i in countGrid)
					for(let j in countGrid[i]){
						let type = cellTypes[countGrid[i][j][0]].nextType(countGrid[i][j].slice(1));
						if(type){
							if(!(i in grid))
								grid[i] = [];
							grid[i][j] = type;
						}
					}
				drawGrid();

				if(view == "run" && !paused)
					setTimeout(timeStep, speed);

				controls.children[2].innerText = ++time + " iterations";
			}
			function resetGrid(){
				grid = [];
				countGrid = [];
				time = 0;
				paused = true;
				selectedCellType = 0; //temp
				mouse = {left:false, right:false, x:0, y:0, dx:0, dy:0};
				camera = {x:0, y:0, zoom:2, zoomF:2.0};

				setView("run");
				zoomUpdate();
				//createDisplayGrid();
				gridDisplay.width  = gridDisplay.clientWidth;
				gridDisplay.height = gridDisplay.clientHeight;
				gridDisplay.style.backgroundColor = cellTypes[0].color;
				drawGrid();

				cellTypeSelector.innerHTML = cellTypes.map((type, i) => "<div style='background:" + type.color + "' onclick='selectCellType(" + i + ")'></div>").join("");
				selectCellType(1);
				controls.children[0].innerText = "Play";
				controls.children[2].innerText = "0 iterations";

				//gridContainer.style.background = cellTypes[0].color;
				//cellColorsCSS.innerHTML = cellTypes.map((type, i) => ".cellType-" + i + "{background:" + type.color + ";}").join("\n");
				cellTypes.forEach(type => type.rules.forEach(rule => rule.parse()));
			}

			function rowIsEmpty(x){
				for(let i in grid[x])
					return false;
				return true;
			}


			const range = (max, min = 0) => new Array(max - min).fill(0).map((x,i) => i + min);
			const inRange = (val, min, max) => min <= val && val <= max;
			const mod = (num, base) => num - Math.floor(num / base) * base;
			const multiSplit = (str, delims) => delims.length ? str.split(delims[0]).map(sub => multiSplit(sub, delims.slice(1))) : str;
			const multiJoin = (arr, opers) => {
				if(!opers.length) return arr;
				if(typeof opers[0] == "function")
					return opers[0](multiJoin(arr, opers.slice(1)));
				arr = arr.map(x => multiJoin(x, opers.slice(1)));
				return opers[0] === false ? arr : arr.join(opers[0]);
			}
			Object.defineProperty(Array.prototype, "swap", {value: function(i, j){
				let temp = this[i];
				this[i] = this[j];
				this[j] = temp;
				return this;
			}});
			Object.defineProperty(Array.prototype, "moveBefore", {value: function(i, j){
				this.splice(j - (i < j), 0, this.splice(i, 1)[0]);
				return this;
			}});
			Object.defineProperty(String.prototype, "filter", {value: function(regex){
				return (this.match(regex) || []).join("");
			}})
			document.oncontextmenu = () => false;


			function saveDesignAsText(){
				textSaveBox.value = "<<" + cellTypes.map(type => [
					type.name.filter(/[^;]+/g),
					type.color.slice(1),
					(type.x / cellTypeSVG.clientWidth ).toString().match(/\d+$/).toString().slice(0, 4),
					(type.y / cellTypeSVG.clientHeight).toString().match(/\d+$/).toString().slice(0, 4),
					type.rulePriority.map((x, i) => x == i ? "" : x).join(),
					...type.rules.map(rule => rule.text || " ")
				].join("\\")).join(";") + ">>";
			}
			function loadDesignFromText(text){
				cellTypes = [];
				text.slice(2, -2).split(";").map(newType => newType.split("\\")).forEach(
					([name, color, x, y, priority, ...rules]) => {
						console.log(priority);
						cellTypes.push(new CellType(
							name,
							"#" + color,
							priority.split(",").map((x, i) => +(x || i)),
							rules,
							"0." + x,
							"0." + y
						));
					}
				);
				redrawCellTypes();
				editCellType(1);
			}


			let mouseEventHandlers = [
				["mousedown", evt => {
					if(evt.button == 0) mouse.left  = true;
					if(evt.button == 2) mouse.right = true;

					onMouseEvent(evt);
				}],
				["mouseup", evt => {
					if(evt.button == 0) mouse.left  = false;
					if(evt.button == 2) mouse.right = false;

					onMouseEvent(evt);
				}],
				["mousemove", onMouseEvent]
			];
			function getMouseInputFrom(el){
				for(let [eventType, handler] of mouseEventHandlers)
					el.addEventListener(eventType, handler);
			}

			getMouseInputFrom(gridDisplay);
			getMouseInputFrom(cellTypeSVG);
			getMouseInputFrom(cellTypeOptions);
			gridDisplay.addEventListener("wheel", evt => {
				camera.zoomF = Math.max(Math.min(camera.zoomF - evt.wheelDelta/150, 30), 0);
				camera.zoom = /*Math.round*/(camera.zoomF);

				camera.x += mouse.x/cellSize;
				camera.y += mouse.y/cellSize;
				zoomUpdate();
				camera.x -= mouse.x/cellSize;
				camera.y -= mouse.y/cellSize;

				drawGrid();
			});
			document.addEventListener("keydown", evt => {
				if(view == "run"){
					if(evt.keyCode == 32) controlFunctions[0]();
					else if(evt.key == "s" && paused) timeStep();
					else if(evt.key == "escape") setView("design");
					else if((evt.key - 1) in cellTypes) selectCellType(evt.key - 1);
				}
			});

			function onMouseEvent(evt){
				mouse.dx = evt.clientX - mouse.x;
				mouse.dy = evt.clientY - mouse.y;
				mouse.x = evt.clientX;
				mouse.y = evt.clientY;
				mouse.shift = evt.shiftKey;

				if(view == "run"){
					if(mouse.right){
						camera.x -= mouse.dx / cellSize;
						camera.y -= mouse.dy / cellSize;
						camera.xc = Math.floor(camera.x);
						camera.yc = Math.floor(camera.y);
					}

					let x = Math.floor(mouse.x / cellSize + camera.x);
					let y = Math.floor(mouse.y / cellSize + camera.y);

					if(mouse.left){
						if(selectedCellType == 0){
							if(x in grid){
								delete grid[x][y];
								if(rowIsEmpty(x))
									delete grid[x];
							}
						}
						else{
							if(!grid[x])
								grid[x] = [];
							grid[x][y] = selectedCellType;
						}
					}

					/*if(!showGrid)
						createDisplayGrid();
					else if(mouse.right)
						moveDisplayGrid();
					else if(mouse.left)
						setDisplayCell(x + Math.floor(camera.x), y + Math.floor(camera.y), selectedCellType);*/
					if(mouse.left || mouse.right)
						drawGrid();
				}
				else if(evt.target == cellTypeSVG || evt.target.parentElement == cellTypeSVG){
					let closest = -1, d = 25;
					for(let i in cellTypes){
						let dist = Math.sqrt((mouse.x - mouse.dx - cellTypes[i].x)**2 + (mouse.y - mouse.dy - cellTypes[i].y)**2);
						if(dist <= 25 && dist <= d){
							closest = Number(i);
							d = dist;
						}
					}

					if(closest >= 0){
						let circle = cellTypeCircle(closest);
						if(mouse.right){
							cellTypes[closest].x += mouse.dx;
							cellTypes[closest].y += mouse.dy;
							circle.setAttribute("cx", cellTypes[closest].x);
							circle.setAttribute("cy", cellTypes[closest].y);
						}
						else if(mouse.left){
							if(mouse.shift){
								//add type to selected rule, might need weird anti-deselection code
							}
							else{
								editCellType(closest);
							}
						}
					}
					else if(mouse.left)
						editCellType(-1);
				}
				else{
					if(draggingRule >= 0){
						if(mouse.right){
							let translateY = Math.max(Math.min(mouse.y - cellTypeRules.offsetTop - draggingRule*29 - draggingRuleY, (cellTypes.length - draggingRule - 1)*29), -draggingRule*29);
							//console.log(Math.abs(translateY) >= 16);
							//console.log(draggingRule);
							if(Math.abs(translateY) > 16){
								Object.assign(cellTypeRules.children[draggingRule].style, {
									transform: "",
									zIndex: ""
								});

								let newPriority = draggingRule + Math.round(translateY / 29);
								console.log(newPriority);
								cellTypes[selectedCellType].rulePriority.moveBefore(draggingRule, newPriority + (newPriority > draggingRule));
								cellTypeRules.children[newPriority][draggingRule > newPriority ? "before" : "after"](cellTypeRules.children[draggingRule]);

								translateY -= (newPriority - draggingRule) * 29;
								draggingRule = newPriority;
							}

							Object.assign(cellTypeRules.children[draggingRule].style, {
								transform: "translate(0px," + translateY + "px)",
								zIndex: 10000
							});
							//cellTypeRules.style.borderBottom = draggingRule == cellTypes.length - 1 ? "1px solid gray" : "1px solid transparent";
						}
						else{
							Array.from(cellTypeRules.children).forEach(el => {
								el.style.transform = "";
								el.style.zIndex = "";
								//el.style.borderTop = "";
							});
							//cellTypeRules.style.borderBottom = "none";
							draggingRule = -1;
						}
					}
				}
			}



			let controlFunctions = [
				() => {
					paused = !paused;
					if(!paused) timeStep();
					controls.children[0].innerText = paused ? "Play" : "Stop";
				},
				() => speed = 1000 / controls.children[4].value,
				() => {
					showCellBorders = !showCellBorders;
					cellBordersCSS.innerHTML = showCellBorders ? ".cell{border:1px solid #303030}" : "";
				},
				() => {
					showGrid = !showGrid;
					createDisplayGrid();
				}
			];


			//default (Conway's Game of Life)
			cellTypes.push(new CellType("Dead" , undefined, [0, 1], ["", ".1=3"]    , 1/4));
			cellTypes.push(new CellType("Alive", "#FFD700", [0, 1], [".1=-1,4-", ""], 3/4));
			redrawCellTypes();
			editCellType(1);


		</script>

	</body>
</html>
