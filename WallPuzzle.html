<!DOCTYPE html>
<html lang="en" dir="ltr">
	<head>
		<meta charset="utf-8">
		<title>Not really minesweeper</title>
		<style type="text/css">
			body {
				background: gray;
			}

			.center {
				position: absolute;
				left: 50%;
				top: 50%;
				transform: translate(-50%, -50%);
			}

			#menu {
				padding: 20px;
				border: 1px solid #202020;
			}

			.options {
				display: flex;
			}
			.options > div {
				margin: 20px;
			}
			.options > div, #AI-help {
				background: darkgray;
				border: 1px solid #202020;

				width: 60px;
				height: 60px;
				padding: 5px;
				box-sizing: border-box;

				text-align: center;
				user-select: none;

				transition: background 0.1s;
			}
			.options > div:hover, #AI-help:hover {
				background: #CCCCCC;
			}

			#AI-help {
				position: absolute;
				right: 30px;
				bottom: 30px;
			}
			#AI-help.on {
				background: lime;
			}
			#AI-help.on:hover {
				background: #00AA00;
			}

			#game-over {
				padding: 10px;
				border: 1px solid black;
				background: #FFFFFF30;
			}

			#game-canvas {
				width: 70%;
				height: 80%;
			}
		</style>
	</head>
	<body>
		<div id="menu" class="center">
			<div class="options">
				<div onclick="start(5, 5)">5x5</div>
				<div onclick="start(9, 5)">9x5</div>
				<div onclick="start(10, 10)">10x10</div>
				<div onclick="start(20, 10)">20x10</div>
				<div onclick="start(35, 20)">35x20</div>
				<div onclick="start(50, 30)">50x30</div>
			</div>
		</div>
		<div id="AI-help" onclick="toggleAIhelp()">AI help</div>
		<canvas id="game-canvas" class="center" style="display: none"></canvas>
		<div id="game-over" class="center" style = "display: none">
			<center>You won!</center>
			<div class="options">
				<div onclick="start()">Play again</div>
				<div onclick="canvas.style.display = gameOver.style.display = 'none'; menu.style.display = ''">Change settings</div>
			</div>
		</div>
		<script type="text/javascript">
			let menu =         document.getElementById("menu")
			let gameOver =     document.getElementById("game-over")
			let AIhelpButton = document.getElementById("AI-help")
			let canvas =       document.getElementById("game-canvas")
			let ctx = canvas.getContext("2d")

			let view = "menu"
			let width = height = tileSize = 0
			let AIhelp = false
			let canvasMargin = {left: 0, top: 0}
			let targetGrid = [[]]
			let grid = [[]]
			let verticalWalls = [[]]
			let horizontalWalls = [[]]

			let hoverX = hoverY = -1
			let hoverVertical = false

			let numberColors = ["red", "lime", "black"]
			let wallColors = ["#303030", "#303060", "#50AA50"]
			let AIspeed = 1  //ms


			function start(w = width, h = height){
				width = w
				height = h
				view = "game"

				menu.style.display = gameOver.style.display = "none"
				canvas.style.display = ""
				canvas.width  = canvas.clientWidth
				canvas.height = canvas.clientHeight

				tileSize = Math.floor(Math.min((canvas.width - 10) / width, (canvas.height - 10) / height))
				canvasMargin.left = Math.floor((canvas.width  -  width*tileSize)/2)
				canvasMargin.top  = Math.floor((canvas.height - height*tileSize)/2)

				targetGrid       = matrix(width, height, 0)
				grid             = matrix(width, height, 0)
				verticalWalls    = matrix(width - 1, height, () => Math.round(Math.random()))
				horizontalWalls  = matrix(width, height - 1, () => Math.round(Math.random()))
				updateGrid(targetGrid)
				//verticalWalls    = matrix(width - 1, height, () => Math.random() < 0.5)
				//horizontalWalls  = matrix(width, height - 1, () => Math.random() < 0.5)
				verticalWalls  .forEach(col => col.fill(0))
				horizontalWalls.forEach(row => row.fill(0))

				draw()

				if(AIhelp)
					AIsolveBoard()
			}
			function updateGrid(g = grid){
				for(let i of range(width))
					for(let j of range(height)){
						g[i][j] = 0
						for(let x = i - 1;   x in verticalWalls      && !(verticalWalls  [x][j] % 3);   x--) g[i][j]++
						for(let x = i    ;   x in verticalWalls      && !(verticalWalls  [x][j] % 3);   x++) g[i][j]++
						for(let y = j - 1;   y in horizontalWalls[i] && !(horizontalWalls[i][y] % 3);   y--) g[i][j]++
						for(let y = j    ;   y in horizontalWalls[i] && !(horizontalWalls[i][y] % 3);   y++) g[i][j]++
					}
			}
			function draw(){
				ctx.clearRect(0, 0, canvas.width, canvas.height)
				updateGrid()

				if(grid.every((row, i) => row.every((x, j) => x == targetGrid[i][j]))){
					view = "gameOver"
					gameOver.style.display = ""

					horizontalWalls.concat(verticalWalls).forEach(row => row.forEach((x, i) => row[i] = +(x % 3 != 0)))
				}

				let walls = hoverVertical ? verticalWalls : horizontalWalls
				if(hoverX in walls && hoverY in walls[hoverX]){
					ctx.strokeStyle = "#A0A0A0"
					ctx.lineWidth = Math.round(tileSize * 0.15)
					ctx.lineCap = "round"
					if(hoverVertical)
						lineSegment(hoverX + 1, hoverY, hoverX + 1, hoverY + 1)
					else
						lineSegment(hoverX, hoverY + 1, hoverX + 1, hoverY + 1)
				}

				ctx.font = Math.floor(tileSize/2) + "px Courier New"
				ctx.textAlign = "center"
				for(let i of range(width))
					for(let j of range(height)){
						ctx.fillStyle = numberColors[Math.sign(grid[i][j] - targetGrid[i][j]) + 1]
						ctx.beginPath()
						ctx.fillText(targetGrid[i][j], ...coords(i + 0.5, j + 0.75))
						ctx.closePath()
					}

				ctx.lineWidth = 2
				for(let i of range(width - 1))
					for(let j of range(height))
						if(verticalWalls[i][j]){
							ctx.strokeStyle = wallColors[verticalWalls[i][j] - 1]
							lineSegment(i + 1, j, i + 1, j + 1)
						}
				for(let i of range(width))
					for(let j of range(height - 1))
						if(horizontalWalls[i][j]){
							ctx.strokeStyle = wallColors[horizontalWalls[i][j] - 1]
							lineSegment(i, j + 1, i + 1, j + 1)
						}

				ctx.beginPath()
				ctx.strokeStyle = wallColors[0]
				ctx.strokeRect(canvasMargin.left, canvasMargin.top, width*tileSize, height*tileSize)
				ctx.closePath()
			}
			function lineSegment(x1, y1, x2, y2){
				ctx.beginPath()
				ctx.moveTo(...coords(x1, y1))
				ctx.lineTo(...coords(x2, y2))
				ctx.stroke()
				ctx.closePath()
			}
			const coords = (x, y) => [canvasMargin.left + Math.round(x*tileSize), canvasMargin.top + Math.round(y*tileSize)]
			const range = size => new Array(size).fill(0).map((_, i) => +i)
			const matrix = (w, h, f) => typeof f == "function"
				?	new Array(w).fill(0).map(() => new Array(h).fill(0).map(f))
				:	new Array(w).fill(0).map(() => new Array(h).fill(f))

			const sleep = (milliseconds) => {
				return new Promise(resolve => setTimeout(resolve, milliseconds))
			}

			function toggleAIhelp(){
				AIhelp = !AIhelp
				AIhelpButton.classList.toggle("on")
				if(AIhelp)
					AIsolveBoard()
			}
			function AIexamineTile(x, y){
				let total = targetGrid[x][y]

				let maxUp = 0, maxDown = 0, maxLeft = 0, maxRight = 0

				for(let i = 1, branchMin = total; (y - i)     in horizontalWalls[x] && horizontalWalls[x][y - i]     % 3 == 0 && i <= (branchMin = Math.min(branchMin, targetGrid[x][y - i])); maxUp    = i++);
				for(let i = 1, branchMin = total; (y + i - 1) in horizontalWalls[x] && horizontalWalls[x][y + i - 1] % 3 == 0 && i <= (branchMin = Math.min(branchMin, targetGrid[x][y + i])); maxDown  = i++);
				for(let i = 1, branchMin = total; (x - i)     in verticalWalls      && verticalWalls[x - i][y]       % 3 == 0 && i <= (branchMin = Math.min(branchMin, targetGrid[x - i][y])); maxLeft  = i++);
				for(let i = 1, branchMin = total; (x + i - 1) in verticalWalls      && verticalWalls[x + i - 1][y]   % 3 == 0 && i <= (branchMin = Math.min(branchMin, targetGrid[x + i][y])); maxRight = i++);

				let minUp = 0, minDown = 0, minLeft = 0, minRight = 0

				for(let i = 1; i <= maxUp && (y - i) in horizontalWalls[x] && horizontalWalls[x][y - i] == 3; minUp = i++);
				for(let i = 1; i <= maxDown && (y + i - 1) in horizontalWalls[x] && horizontalWalls[x][y + i - 1] == 3; minDown = i++);
				for(let i = 1; i <= maxLeft && (x - i) in verticalWalls && verticalWalls[x - i][y] == 3; minLeft = i++);
				for(let i = 1; i <= maxRight && (x + i - 1) in verticalWalls && verticalWalls[x + i - 1][y] == 3; minRight = i++);


				let minHorizontal = Math.max(total - maxUp - maxDown, minLeft + minRight), minVertical = Math.max(total - maxLeft - maxRight, minUp + minDown)
				minUp    = Math.max(minVertical - maxDown, minUp)
				minDown  = Math.max(minVertical - maxUp, minDown)
				minLeft  = Math.max(minHorizontal - maxRight, minLeft)
				minRight = Math.max(minHorizontal - maxLeft, minRight)

				maxUp    = Math.min(total - minDown  - minLeft - minRight, maxUp)
				maxDown  = Math.min(total - minUp    - minLeft - minRight, maxDown)
				maxLeft  = Math.min(total - minRight - minUp   - minDown , maxLeft)
				maxRight = Math.min(total - minLeft  - minUp   - minDown , maxRight)


				for(let i = 0; i < minUp; i++)
					if((y - i - 1) in horizontalWalls[x])
						horizontalWalls[x][y - i - 1] = 3
				for(let i = 0; i < minDown; i++)
					if((y + i) in horizontalWalls[x])
						horizontalWalls[x][y + i] = 3
				for(let i = 0; i < minLeft; i++)
					if((x - i - 1) in verticalWalls)
						verticalWalls[x - i - 1][y] = 3
				for(let i = 0; i < minRight; i++)
					if((x + i) in verticalWalls)
						verticalWalls[x + i][y] = 3

				if(minUp == maxUp && (y - minUp - 1) in horizontalWalls[x])
					horizontalWalls[x][y - minUp - 1] = 2
				if(minDown == maxDown && (y + minDown) in horizontalWalls[x])
					horizontalWalls[x][y + minDown] = 2
				if(minLeft == maxLeft && (x - minLeft - 1) in verticalWalls)
					verticalWalls[x - minLeft - 1][y] = 2
				if(minRight == maxRight && (x + minRight) in verticalWalls)
					verticalWalls[x + minRight][y] = 2

				return minUp + minDown + minLeft + minRight == total
			}
			async function AIsolveBoard(){
				if(!(AIhelp && view == "game"))
					return;

				updateGrid()

				let completeTiles = matrix(width, height, false)

				let newWalls = wallsToText(), oldWalls = "", changed = true
				while(changed && AIhelp){
					changed = false
					for(let i in grid)
						for(let j in grid[i])
							if(!completeTiles[i][j]){
								if(AIexamineTile(+i, +j))
									completeTiles[i][j] = true

								oldWalls = newWalls
								newWalls = wallsToText()
								if(newWalls != oldWalls){
									changed = true
									draw()
									await sleep(AIspeed)
								}
							}

				}
			}

			const wallsToText = () => horizontalWalls + " " + verticalWalls

			canvas.addEventListener("click", e => {
				if(view != "game")
					return;

				onMouseEvent(e)

				let walls = hoverVertical ? verticalWalls : horizontalWalls
				if(!(hoverX in walls && hoverY in walls[hoverX]))
					return;

				walls[hoverX][hoverY] = 1 - (walls[hoverX][hoverY] % 3 != 0)
				draw()

				if(AIhelp)
					AIsolveBoard()
			})
			canvas.addEventListener("mousemove", e => {
				onMouseEvent(e)
				draw()
			})
			function onMouseEvent(e){
				hoverX = (e.offsetX - canvasMargin.left) / tileSize
				hoverY = (e.offsetY - canvasMargin.top) / tileSize
				hoverVertical = Math.abs((hoverX % 1) - 0.5) > Math.abs((hoverY % 1) - 0.5)

				if(hoverVertical){
					hoverX = Math.round(hoverX) - 1
					hoverY = Math.floor(hoverY)
				}
				else{
					hoverY = Math.round(hoverY) - 1
					hoverX = Math.floor(hoverX)
				}
			}
		</script>
	</body>
</html>
