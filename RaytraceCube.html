<!DOCTYPE html>
<html lang="en" dir="ltr">
	<head>
		<meta charset="utf-8">
		<title>A raytraced cube I guess</title>
		<style>
			body {
				max-height: 100%;
				overflow: hidden;

				font-family: Courier New;
			}

			#main-canvas {
				position: absolute;
				left: 0;
				top: 0;
				width: 100%;
				height: 100%;
			}

			#menu {
				position: absolute;
				left: 50%;
				top: 50%;
				transform: translate(-50%, -50%);

				width: max-content;
				padding: 40px;

				background: #000000D0;
				border: 1px solid black;
				border-radius: 3px;

				color: white;
			}
			#menu table {
				/*margin: 50px auto;*/
				font-size: 15px;
			}
			#menu td:first-child {
				padding-right: 50px;
			}

			.hidden {
				display: none;
			}
		</style>
	</head>
	<body>
		<canvas id="main-canvas"></canvas>
		<div id="menu" class="hidden">
			<table>
				<tr> <td>w</td> <td>forwards</td> </tr>
				<tr> <td>a</td> <td>left</td> </tr>
				<tr> <td>s</td> <td>backwards</td> </tr>
				<tr> <td>d</td> <td>right</td> </tr>
				<tr> <td>q</td> <td>up</td> </tr>
				<tr> <td>e</td> <td>down</td> </tr>
				<tr> <td><br></td> </tr>
				<tr> <td>up arrow</td> <td>look up</td> </tr>
				<tr> <td>down arrow</td> <td>look down</td> </tr>
				<tr> <td>left arrow</td> <td>look left</td> </tr>
				<tr> <td>right arrow</td> <td>look right</td> </tr>
				<tr> <td><br></td> </tr>
				<tr> <td>]</td> <td>+ pixel size</td> </tr>
				<tr> <td>[</td> <td>- pixel size</td> </tr>
				<tr> <td>shift + ]</td> <td>+ field of view</td> </tr>
				<tr> <td>shift + [</td> <td>- field of view</td> </tr>
				<tr> <td><br></td> </tr>
				<tr> <td>l</td> <td>move light source</td> </tr>
			</table>
		</div>
		<script>
			let canvas = document.getElementById("main-canvas")
			let ctx = canvas.getContext("2d")
			let menu = document.getElementById("menu")

			let camera = {
				x: -1.2,
				y: -0.6,
				z: 1.9,
				theta: 0.1,  //0* to 360*
				phi: -0.66,    //-90* to 90*
				thetaFOV: 70,
				focus: 0,
				plane: {center: [], down: [], right: []}
			}
			let blur = 5, blurValue = 1
			let settings = {
				sensitivity: 6 * Math.PI/180,
				moveSpeed: 0.3
			}
			let keys = {
				w:          false,
				a:          false,
				s:          false,
				d:          false,
				q:          false,
				e:          false,
				ArrowUp:    false,
				ArrowDown:  false,
				ArrowLeft:  false,
				ArrowRight: false,
				"{":        false,
				"}":        false
			}

			let objectIntersectRadius = 0.0001
			let renderDistance = 30
			let maxRaySteps = 150


			let sin  = Math.sin .bind(Math)
			let cos  = Math.cos .bind(Math)
			let atan = Math.atan.bind(Math)

			let abs  = Math.abs .bind(Math)
			let max  = Math.max .bind(Math)
			let min  = Math.min .bind(Math)
			let sqrt = Math.sqrt.bind(Math)
			let PI  = Math.PI


			///scene
			class Sphere {
				constructor(x, y, z, r, color){
					this.x = x
					this.y = y
					this.z = z
					this.r = r
					this.color = color
				}
				distance(x, y, z){
					return sqrt(sqr(x - this.x) + sqr(y - this.y) + sqr(z - this.z)) - this.r
				}
				surfaceVector(x, y, z){
					x -= this.x
					y -= this.y
					z -= this.z
					let d = norm([x, y, z])
					return [x/d, y/d, z/d]
				}
			}
			class RectangularPrism {
				constructor(x1, y1, z1, x2, y2, z2, color){
					this.x1 = x1
					this.x2 = x2
					this.y1 = y1
					this.y2 = y2
					this.z1 = z1
					this.z2 = z2
					this.color = color
				}
				distance(x, y, z){
					return sqrt(
						((x < this.x1) != (x < this.x2) ? 0 : sqr(min(abs(x - this.x1), abs(x - this.x2)))) +
						((y < this.y1) != (y < this.y2) ? 0 : sqr(min(abs(y - this.y1), abs(y - this.y2)))) +
						((z < this.z1) != (z < this.z2) ? 0 : sqr(min(abs(z - this.z1), abs(z - this.z2))))
					)
				}
				surfaceVector(x, y, z){
					let dx1 = abs(x - this.x1), dx2 = abs(x - this.x2), sx = Math.sign(this.x2 - this.x1)
					let dy1 = abs(y - this.y1), dy2 = abs(y - this.y2), sy = Math.sign(this.y2 - this.y1)
					let dz1 = abs(z - this.z1), dz2 = abs(z - this.z2), sz = Math.sign(this.z2 - this.z1)

					switch(min(dx1, dx2, dy1, dy2, dz1, dz2)){
						case dx1: return [-sx, 0, 0]
						case dx2: return [ sx, 0, 0]
						case dy1: return [0, -sy, 0]
						case dy2: return [0,  sy, 0]
						case dz1: return [0, 0, -sz]
						case dz2: return [0, 0,  sz]
					}
				}
			}
			class OmnidirectionalLightSource {
				constructor(x, y, z, color, brightness){
					this.x = x
					this.y = y
					this.z = z
					this.color = color
					this.brightness = brightness
				}
				distance(x, y, z){
					return sqrt(sqr(x - this.x) + sqr(y - this.y) + sqr(z - this.z))
				}
				vectorTo(x, y, z){
					let dx = this.x - x
					let dy = this.y - y
					let dz = this.z - z
					let s = sqrt(sqr(dx) + sqr(dy) + sqr(dz))
					return [dx/s, dy/s, dz/s]
				}
			}

			let objects = [
				new Sphere(0.5, -1.5, 0.5, 0.5, [255, 0, 0]),
				new RectangularPrism(0, 0, 0, 1, 1, 1, [0, 255, 0]),
				new RectangularPrism(0.3, 0.3, 1, 0.7, 0.7, 1.4, [0, 255, 255]),
				{
					name: "ground",
					color: [220, 80, 10],
					distance: (x, y, z) => z,
					surfaceVector: () => [0, 0, 1]
				}
			]
			let lightSources = [
				new OmnidirectionalLightSource(3, 2.5, 5, [255, 255, 255], 1),
			]




			function setup(){
				blurValue = 1.5 ** blur
				let w = Math.floor(canvas.clientWidth/blurValue), h = Math.floor(canvas.clientHeight/blurValue)
				if(w != canvas.width || h != canvas.height){
					canvas.width = w
					canvas.height = h
				}

				camera.phiFOV = (h / w) * camera.thetaFOV
				camera.focus = (w / 2) / Math.tan(camera.thetaFOV / 2)

				ctx.beginPath()
				ctx.fillRect(0, 0, w, h)
				ctx.closePath()

				draw()
			}

			function draw(){
				camera.plane.center = [cos(camera.theta)*cos(camera.phi), sin(camera.theta)*cos(camera.phi), sin(camera.phi)]
				camera.plane.down   = [cos(camera.theta)*cos(camera.phi - PI/2), sin(camera.theta)*cos(camera.phi - PI/2), sin(camera.phi - PI/2)]
				camera.plane.right  = [cos(camera.theta + PI/2), sin(camera.theta + PI/2), 0]


				let off = 0
				let image = ctx.getImageData(0, 0, canvas.width, canvas.height)
				let id = image.data

				for(let j = 0; j < canvas.height; j++)
					for(let i = 0; i < canvas.width; i++){
						let [dx, dy, dz] = pixelCoordToVector((i - canvas.width/2) * blurValue, (j - canvas.height/2) * blurValue)
						let [r, g, b] = rayColor(dx, dy, dz)

						id[off]     = r
						id[off + 1] = g
						id[off + 2] = b

						off += 4
					}
				ctx.putImageData(image, 0, 0)
			}
			function pixelCoordToVector(x, y){
				let s = 21000 / camera.thetaFOV
				let P = camera.plane

				let X = P.center[0] + P.right[0] * x/s + P.down[0] * y/s
				let Y = P.center[1] + P.right[1] * x/s + P.down[1] * y/s
				let Z = P.center[2] + P.right[2] * x/s + P.down[2] * y/s

				//let theta = angleTo(X, Y)
				//let phi = angleTo(Math.sqrt(X*X + Y*Y), Z)

				let l = norm([X, Y, Z])

				return [X/l, Y/l, Z/l]
			}
			function rayColor(dx, dy, dz, x = camera.x, y = camera.y, z = camera.z){
				let minRadius = Infinity, step = 0, collisionDetails = null
				cameraToTarget: for(; ; step++){
					let stepRadius = Infinity
					for(let o of objects){
						let d = o.distance(x, y, z)
						if(d < objectIntersectRadius){
							collisionDetails = [o, step, minRadius, cameraDistance(x, y, z)]
							x -= dx * objectIntersectRadius
							y -= dy * objectIntersectRadius
							z -= dz * objectIntersectRadius
							break cameraToTarget
						}
						stepRadius = min(stepRadius, d)
					}

					minRadius = min(minRadius, stepRadius)

					x += dx * stepRadius
					y += dy * stepRadius
					z += dz * stepRadius

					if(cameraDistance(x, y, z) > renderDistance || step >= maxRaySteps)
						return rayShading({color: [100, 100, 255], name: "sky"}, maxRaySteps, minRadius, PI/2 - angleTo(Math.sqrt(dx*dx + dy*dy), dz))
				}

				let totalLight = 0
					for(let source of lightSources)
						totalLight += sourceRayLight(x, y, z, source, collisionDetails[0])

				collisionDetails[1] = totalLight
				return rayShading(...collisionDetails)
			}
			function sourceRayLight(x, y, z, source, object){
				let r = source.distance(x, y, z)//soon
				let surface = object.surfaceVector(x, y, z)
				let [dx, dy, dz] = source.vectorTo(x, y, z)

				targetToLightSource: for(let step = 0; step < maxRaySteps; step++){
					let stepRadius = Infinity

					for(let o of objects){
						let d = o.distance(x, y, z)
						if(d < objectIntersectRadius)
						return 0.25
						stepRadius = min(stepRadius, d)
					}

					let d = source.distance(x, y, z)
					if(d < objectIntersectRadius)
					break  //0.5 / (1.5 ** r) + 0.5
					stepRadius = min(stepRadius, d)

					x += dx * stepRadius
					y += dy * stepRadius
					z += dz * stepRadius
				}

				return (dx*surface[0] + dy*surface[1] + dz*surface[2]) * 0.75 + 0.25
			}
			function rayShading({color: [r, g, b], name: object}, steps, minRadius, distance = 1){
				let shade = 1/steps
				if(object == "sky")
					shade = 1.1 ** (distance * 3 - 4)
				return [r/shade, g/shade, b/shade]
			}

			const mod = (x, m) => x - Math.floor(x / m) * m
			const sqr = x => x*x
			const dotProduct = (v1, v2) => v1[0]*v2[0] + v1[1]*v2[1] + v1[2]*v2[2]
			const norm = v => Math.sqrt(v[0]*v[0] + v[1]*v[1] + v[2]*v[2])
			const angleTo = (x, y) => atan(y / x) + (x < 0 ? PI : 0)
			const cameraDistance = (x, y, z) => sqrt(sqr(x - camera.x) + sqr(y - camera.y) + sqr(z - camera.z))

			function frame(){
				moveCamera()

				let redraw = false
				for(let k in keys)
					redraw = redraw || keys[k]
				if(redraw)
					requestAnimationFrame(draw)
			}
			function moveCamera(){
				if(keys.ArrowUp)    camera.phi   += settings.sensitivity
				if(keys.ArrowDown)  camera.phi   -= settings.sensitivity
				if(keys.ArrowRight) camera.theta += settings.sensitivity
				if(keys.ArrowLeft)  camera.theta -= settings.sensitivity

				if(keys.w){
					camera.x += cos(camera.theta) * settings.moveSpeed
					camera.y += sin(camera.theta) * settings.moveSpeed
				}
				if(keys.s){
					camera.x -= cos(camera.theta) * settings.moveSpeed
					camera.y -= sin(camera.theta) * settings.moveSpeed
				}
				if(keys.a){
					camera.x += cos(camera.theta - PI/2) * settings.moveSpeed
					camera.y += sin(camera.theta - PI/2) * settings.moveSpeed
				}
				if(keys.d){
					camera.x += cos(camera.theta + PI/2) * settings.moveSpeed
					camera.y += sin(camera.theta + PI/2) * settings.moveSpeed
				}
				if(keys.q)  camera.z += settings.moveSpeed
				if(keys.e)  camera.z -= settings.moveSpeed

				if(keys["}"]) camera.thetaFOV += 5
				if(keys["{"]) camera.thetaFOV -= 5


				settings.moveSpeed = 0.3 * min(...objects.map(object => object.distance(camera.x, camera.y, camera.z)), 1)
			}


			setup()
			setInterval(frame, 100)


			document.addEventListener("keydown", e => {
				for(let k in keys)
					if(e.key == k)
						keys[k] = true

				switch(e.key){
					case "]":
						blur++
						setup()
						break
					case "[":
						blur = Math.max(blur - 1, 0)
						setup()
						break
					case "l":
						lightSources[0].x = camera.x
						lightSources[0].y = camera.y
						lightSources[0].z = camera.z
						draw()
						break

					case "Escape":
						menu.classList.toggle("hidden")
						return
				}
			})
			document.addEventListener("keyup", e => {
				for(let k in keys)
					if(e.key == k)
						keys[k] = false
			})
		</script>
	</body>
</html>
