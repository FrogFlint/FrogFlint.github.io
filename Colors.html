<!DOCTYPE html>
<html>

<head>

	<style>
		* {
			padding: 0;
			margin: 0;
		}
		
		canvas {
			background: black;
			display: block;
			margin: 0 auto;
		}
	</style>

<title>Color Game</title>
</head>

<body>

	<canvas id="myCanvas" width="800" height="600"></canvas>

	<body style="background-color:#535353;">

		<SCRIPT LANGUAGE="JavaScript">
			
			
			var canvas = document.getElementById("myCanvas");
			var ctx = canvas.getContext("2d");
			
			
			var tile = [[]];
			var player = [null,[],[]];
			var bullet = [null,[],[]];
			
			var index1 = 0;
			var index2 = 0;
			
			var cornerDistance = 0;
			
			var tileSize = 50;
			var boardSize = {x:Math.floor(canvas.width / tileSize),y:Math.floor(canvas.height / tileSize)};
			var teamSize = 3;
			
			var maxMoveSpeed = 6;
			var playerAcceleration = 2;
			
			var humanPlayer = {team:2,index:0};
			var teamColor = ["Red","White","Black"];
			
			
			var mouse = {x:0,y:0};
			
			
			
			
			
			
			
			for(index1 = 0;index1 < boardSize.x;index1++){
				tile[index1] = [];
				for(index2 = 0;index2 < boardSize.y;index2++){
					tile[index1][index2] = Math.floor(2 * index2 / boardSize.y) + 1;
					if(Math.random() < (1 / (Math.abs(index2 + 0.5 - boardSize.y/2) * 4))){
						tile[index1][index2] = 3 - tile[index1][index2];
					}
				}
			}
			for(index1 = 1;index1 <= 2;index1++){
				player[index1] = [];
				for(index2 = 0;index2 < teamSize;index2++){
					player[index1][index2] = {
						Xpos:0,
						Ypos:0,
						Xspeed:0,
						Yspeed:0,
						dead:false,
						reload:0,
						human:false,
						AI:"easy",
						
						up:0,
						down:0,
						left:0,
						right:0
					}
				}
			}
			player[humanPlayer.team][humanPlayer.index].human = true;
			player[humanPlayer.team][humanPlayer.index].AI = "none";
			player[humanPlayer.team][humanPlayer.index].Xpos = 500;
			player[humanPlayer.team][humanPlayer.index].Ypos = 500;
			
			
			
			function getMousePos(canvas, evt) {
				var rect = canvas.getBoundingClientRect();
				return {
					x: (evt.clientX - rect.left),
					y: (evt.clientY - rect.top)
				};
			}
			
			
			function distance(x1,y1,x2,y2){
				return Math.sqrt(Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2));
			}
			function round(base, factor){
				return base - (base % factor);
			}
			
			
			function movePlayers(){
				for(index1 = 1;index1 <= 2;index1++){
					for(index2 = 0;index2 < teamSize;index2++){
						player[index1][index2].Xspeed = Math.max(Math.min(player[index1][index2].Xspeed, maxMoveSpeed), -maxMoveSpeed);
						player[index1][index2].Yspeed = Math.max(Math.min(player[index1][index2].Yspeed, maxMoveSpeed), -maxMoveSpeed);
						
						player[index1][index2].Xpos += player[index1][index2].Xspeed;
						player[index1][index2].Ypos += player[index1][index2].Yspeed;
						
						
						if(player[index1][index2].Xpos - 15 < 0 || (player[index1][index2].Xpos > tileSize && 
						  (Math.floor((player[index1][index2].Xpos - 15)/tileSize) != Math.floor((player[index1][index2].Xpos)/tileSize)) && 
						  tile[Math.floor((player[index1][index2].Xpos - 15)/tileSize)][Math.floor(player[index1][index2].Ypos/tileSize)] != index1)){
							player[index1][index2].Xpos = Math.floor(player[index1][index2].Xpos / tileSize) * tileSize + 15;
							player[index1][index2].Xspeed = 0;
						}
						if(player[index1][index2].Xpos + 15 > boardSize.x * tileSize || (player[index1][index2].Xpos < (boardSize.x - 1) * tileSize && 
						  (Math.floor((player[index1][index2].Xpos + 15)/tileSize) != Math.floor((player[index1][index2].Xpos)/tileSize)) && 
						  tile[Math.floor((player[index1][index2].Xpos + 15)/tileSize)][Math.floor(player[index1][index2].Ypos/tileSize)] != index1)){
							player[index1][index2].Xpos = Math.ceil(player[index1][index2].Xpos / tileSize) * tileSize - 15;
							player[index1][index2].Xspeed = 0;
						}
						if(player[index1][index2].Ypos - 15 < 0 || (player[index1][index2].Ypos > tileSize && 
						  (Math.floor((player[index1][index2].Ypos - 15)/tileSize) != Math.floor((player[index1][index2].Ypos)/tileSize)) && 
						  tile[Math.floor(player[index1][index2].Xpos/tileSize)][Math.floor((player[index1][index2].Ypos - 15)/tileSize)] != index1)){
							player[index1][index2].Ypos = Math.floor(player[index1][index2].Ypos / tileSize) * tileSize + 15;
							player[index1][index2].Yspeed = 0;
						}
						if(player[index1][index2].Ypos + 15 > boardSize.y * tileSize || (player[index1][index2].Ypos < (boardSize.y - 1) * tileSize && 
						  (Math.floor((player[index1][index2].Ypos + 15)/tileSize) != Math.floor((player[index1][index2].Ypos)/tileSize)) && 
						  tile[Math.floor(player[index1][index2].Xpos/tileSize)][Math.floor((player[index1][index2].Ypos + 15)/tileSize)] != index1)){
							player[index1][index2].Ypos = Math.ceil(player[index1][index2].Ypos / tileSize) * tileSize - 15;
							player[index1][index2].Yspeed = 0;
						}
						
						cornerDistance = distance(player[index1][index2].Xpos, player[index1][index2].Ypos, round(player[index1][index2].Xpos,tileSize), round(player[index1][index2].Ypos,tileSize));
						if(cornerDistance < 15 && cornerDistance != 0 && tile[Math.floor((player[index1][index2].Xpos - 15)/tileSize)][Math.floor((player[index1][index2].Ypos - 15)/tileSize)] != index1){
							player[index1][index2].Xpos = round(player[index1][index2].Xpos,tileSize) + (player[index1][index2].Xpos - round(player[index1][index2].Xpos,tileSize)) * 15/cornerDistance;
							player[index1][index2].Ypos = round(player[index1][index2].Ypos,tileSize) + (player[index1][index2].Ypos - round(player[index1][index2].Ypos,tileSize)) * 15/cornerDistance;
							player[index1][index2].Xspeed = 0;
							player[index1][index2].Yspeed = 0;
						}
						cornerDistance = distance(player[index1][index2].Xpos, player[index1][index2].Ypos, round(player[index1][index2].Xpos,tileSize) + tileSize, round(player[index1][index2].Ypos,tileSize));
						if(cornerDistance < 15 && cornerDistance != 0 && tile[Math.floor((player[index1][index2].Xpos + 15)/tileSize)][Math.floor((player[index1][index2].Ypos - 15)/tileSize)] != index1){
							player[index1][index2].Xpos = round(player[index1][index2].Xpos,tileSize) + tileSize + (player[index1][index2].Xpos - round(player[index1][index2].Xpos,tileSize) - tileSize) * 15/cornerDistance;
							player[index1][index2].Ypos = round(player[index1][index2].Ypos,tileSize) + (player[index1][index2].Ypos - round(player[index1][index2].Ypos,tileSize)) * 15/cornerDistance;
							player[index1][index2].Xspeed = 0;
							player[index1][index2].Yspeed = 0;
						}
						cornerDistance = distance(player[index1][index2].Xpos, player[index1][index2].Ypos, round(player[index1][index2].Xpos,tileSize) + tileSize, round(player[index1][index2].Ypos,tileSize) + tileSize);
						if(cornerDistance < 15 && cornerDistance != 0 && tile[Math.floor((player[index1][index2].Xpos + 15)/tileSize)][Math.floor((player[index1][index2].Ypos + 15)/tileSize)] != index1){
							player[index1][index2].Xpos = round(player[index1][index2].Xpos,tileSize) + tileSize + (player[index1][index2].Xpos - round(player[index1][index2].Xpos,tileSize) - tileSize) * 15/cornerDistance;
							player[index1][index2].Ypos = round(player[index1][index2].Ypos,tileSize) + tileSize + (player[index1][index2].Ypos - round(player[index1][index2].Ypos,tileSize) - tileSize) * 15/cornerDistance;
							player[index1][index2].Xspeed = 0;
							player[index1][index2].Yspeed = 0;
						}
						cornerDistance = distance(player[index1][index2].Xpos, player[index1][index2].Ypos, round(player[index1][index2].Xpos,tileSize), round(player[index1][index2].Ypos,tileSize) + tileSize);
						if(cornerDistance < 15 && cornerDistance != 0 && tile[Math.floor((player[index1][index2].Xpos - 15)/tileSize)][Math.floor((player[index1][index2].Ypos + 15)/tileSize)] != index1){
							player[index1][index2].Xpos = round(player[index1][index2].Xpos,tileSize) + (player[index1][index2].Xpos - round(player[index1][index2].Xpos,tileSize)) * 15/cornerDistance;
							player[index1][index2].Ypos = round(player[index1][index2].Ypos,tileSize) + tileSize + (player[index1][index2].Ypos - round(player[index1][index2].Ypos,tileSize) - tileSize) * 15/cornerDistance;
							player[index1][index2].Xspeed = 0;
							player[index1][index2].Yspeed = 0;
						}
					}
				}
			}
			function moveBullets(){}
			function shoot(team, player, x, y){}
			function killPlayers(){}
			
			function drawBoard(){
				for(index1 = 0;index1 < boardSize.x;index1++){
					for(index2 = 0;index2 < boardSize.y;index2++){
						ctx.beginPath();
						ctx.fillStyle = teamColor[tile[index1][index2]];
						ctx.fillRect(index1 * tileSize, index2 * tileSize, tileSize, tileSize);
						ctx.closePath();
					}
				}
			}
			function drawPlayers(){
				for(index1 = 1;index1 <= 2;index1++){
					for(index2 = 0;index2 < teamSize;index2++){
						ctx.beginPath();
						ctx.fillStyle = teamColor[3 - index1];
						ctx.arc(player[index1][index2].Xpos, player[index1][index2].Ypos, 15, 0, Math.PI*2);
						if(!player[index1][index2].dead){
							ctx.fill();
						}
						ctx.closePath();
					}
				}
			}
			function drawBullets(){}
			
			function translateInputs(){
				for(index1 = 1;index1 <= 2;index1++){
					for(index2 = 0;index2 < teamSize;index2++){
						
						if(player[index1][index2].up + player[index1][index2].down == 1){
							player[index1][index2].Yspeed += playerAcceleration * (player[index1][index2].down - player[index1][index2].up);
						}
						else if(player[index1][index2].Yspeed != 0){
							player[index1][index2].Yspeed -= playerAcceleration * player[index1][index2].Yspeed / Math.abs(player[index1][index2].Yspeed);
						}
						if(player[index1][index2].left + player[index1][index2].right == 1){
							player[index1][index2].Xspeed += playerAcceleration * (player[index1][index2].right - player[index1][index2].left);
						}
						else if(player[index1][index2].Xspeed != 0){
							player[index1][index2].Xspeed -= playerAcceleration * player[index1][index2].Xspeed / Math.abs(player[index1][index2].Xspeed);
						}
					}
				}
			}
			function AI(type){}
			
			
			
			
			
			//document.addEventListener("click", functionName);
			
			

			document.addEventListener("keydown", keyDownHandler, false);
			document.addEventListener("keyup", keyUpHandler, false);
			function keyDownHandler(e) {

				if(e.keyCode == 87){
					player[humanPlayer.team][humanPlayer.index].up = 1;
				}
				if(e.keyCode == 65){
					player[humanPlayer.team][humanPlayer.index].left = 1;
				}
				if(e.keyCode == 83){
					player[humanPlayer.team][humanPlayer.index].down = 1;
				}
				if(e.keyCode == 68){
					player[humanPlayer.team][humanPlayer.index].right = 1;
				}
			}
			function keyUpHandler(e) {

				if(e.keyCode == 87){
					player[humanPlayer.team][humanPlayer.index].up = 0;
				}
				if(e.keyCode == 65){
					player[humanPlayer.team][humanPlayer.index].left = 0;
				}
				if(e.keyCode == 83){
					player[humanPlayer.team][humanPlayer.index].down = 0;
				}
				if(e.keyCode == 68){
					player[humanPlayer.team][humanPlayer.index].right = 0;
				}
			}
			
			
			
			
			
			
			function draw(evt) {     //=========================================================================================================================================================================================================
				
				ctx.clearRect(0,0,canvas.width,canvas.height);
				
				
				
				
				
				
				translateInputs();
				
				movePlayers();
				
				
				drawBoard();
				drawPlayers();
				
				
				
				
				setTimeout(draw, 20);
			}
			draw();
			
		</SCRIPT>
	</body>
</html>
