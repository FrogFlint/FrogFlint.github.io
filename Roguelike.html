<!DOCTYPE html>
<html>

<head>

	<style>
		* {
			padding: 0;
			margin: 0;
		}
		
		canvas {
			background: black;
			display: block;
			margin: 0 auto;
		}
	</style>

<title>Dungeon Crawler</title>
</head>

<body>

	<canvas id="myCanvas" width="1350" height="640"></canvas>

	<body style="background-color:black;">

		<SCRIPT LANGUAGE="JavaScript">
			
			
			var canvas = document.getElementById("myCanvas");
			var ctx = canvas.getContext("2d");
			
			var map = [[{}]];
			var loadRadius = 500;
			var mapEdge = {top:100000 - loadRadius, bottom:100000 + loadRadius, left:100000 - loadRadius, right:100000 + loadRadius};
			var tileSize = 48;
			
			var GUIscale = 1;
			
			var gameState = "playing";  //playing, dead, choosing
			var playerView = "game";  //game, inventory, map
			
			var inventorySize = {width:7, height:4};
			
			var enemy = [{}];
			var projectile = {player:[{}], enemy:[{}]};
			var itemDrop = [{}];
			var dust = [{}];
			
			var mouse = {x:0,y:0};
			var crosshair = {x:canvas.width/2, y:canvas.height/2};
			var drawPos = {x:0,y:0};
			
			var player = {
				pos:{x:100000.5, y:100000.5},
				speed:{x:0, y:0},
				size:0.8,
				dead:false,
				inventory:[[{}]],
				specialSlots:{ammo:[{}]},
				equipment:{},
				dragItem:{name:""},
				effects:[{name:"",duration:20}],
				slot:0,
				facing:0,
				itemCooldown:0,
				stat:{
					health:80,
					mana:10,
					maxLife:80,
					maxMana:10,
					speed:0.2,
					acceleration:0.03,
					regen:0.1,
					manaRegen:0.03,
					armor:0,
					damageBonus:0
				},
				key:{up:false,down:false,left:false,right:false,click:false}
			};
			
			var index1, index2;
			
			for(index1 = 0;index1 < 7;index1++){
				player.inventory[index1] = [];
				for(index2 = 0;index2 < 6;index2++){
					player.inventory[index1][index2] = {name:"",itemSize:32};
				}
			}
			var equipmentSlots = ["head","body","legs","feet","arm1","arm2","hands","neck","back"];
			var equipmentSlotLocation = [{x:950,y:200},{x:950,y:270},{x:950,y:340},{x:950,y:410},{x:880,y:270},{x:1020,y:270},{x:1160,y:340},{x:1160,y:270},{x:1160,y:200}];
			for(index1 = 0;index1 < equipmentSlots.length;index1++){
				player.equipment[equipmentSlots[index1]] = {name:"",itemSize:32};
			}
			
			
			var enemyCap = 250;
			var dustCap = 1000;
			var projectileCap = 1000;
			var projOwner = ["player","enemy"];
			
			for(index1 = mapEdge.left;index1 <= mapEdge.right;index1++){
				map[index1] = [];
				for(index2 = mapEdge.top;index2 <= mapEdge.bottom;index2++){
					map[index1][index2] = {
						discovered:false,
						wall:true,
						object:"", //door, chest, forge
						open:false,
						disabled:false,
						rotation:0
					};
				}
			}
			
			for(index1 = 0;index1 < enemyCap;index1++){
				enemy[index1] = {
					active:false,
					pos:{x:0, y:0},
					speed:{x:0, y:0},
					type:"",
					size:0.8,
					target:null,
					effects:[{name:"",duration:20}],
					facing:0,
					cooldown:0,
					stat:{
						health:100,
						mana:0,
						maxLife:100,
						maxMana:10,
						speed:1,
						regen:0.1,
						manaRegen:0.1,
						armor:0
					}
				}
			}
			
			for(index1 = 0;index1 < 2;index1++){
				for(index2 = 0;index2 < projectileCap;index2++){
					projectile[projOwner[index1]][index2] = {
						active:false,
						pos:{x:0, y:0},
						speed:{x:0, y:0},
						type:"",
						size:0,
						damage:0
					}
				}
			}
			for(index1 = 0;index1 < dustCap;index1++){
				dust[index1] = {
					active:false,
					type:"",
					color:"#FFFFFF",
					pos:{x:0, y:0},
					speed:{x:0, y:0}
				}
			}
			
			var mouseControls = true;
			var controls = ["w","s","a","d","q","e","j"];
			var direction = ["up","down","left","right"];
			var edgeDirection = ["top","bottom","left","right"];
			//var stats = ["maxLife","maxMana","speed","acceleration","regen","manaRegen","armor","damageBonus"];
			
			var item, armorSet, craftingRecipe, baseProjectile, baseEnemy, baseDust;
			function setBaseStats(){
				item = [
					{
						name:"Base Item",
						tooltip:["An item"],
						type:["weapon","equipment","ammo"],
						subType:[["swing","stab","shoot"],["head","body","legs","feet","arm","hands","neck","back"]],
						damage:0,
						damageType:["melee","ranged","magic"],
						speed:0,
						autoUse:false,
						showHand:{main:false, off:false},
						ammoType:["arrows","knives"],
						projectile:"",
						velocity:0,
						useMana:0,
						bonus:{armor:0},
						stack:1,
						maxStack:1,
						size:16,
						itemSize:32,
						tier:0,
						rarity:0
					},
					{
						name:"Wooden Sword",
						tooltip:["A basic wood sword"],
						type:"weapon",
						subType:"swing",
						damage:3,
						damageType:"melee",
						speed:15,
						autoUse:false,
						showHand:{main:true, off:false},
						maxStack:1,
						size:26,
						itemSize:32,
						tier:1,
						rarity:1
					},
					{
						name:"Knives",
						tooltip:["When kept in your hotbar, this knife can be used in conjunction with any one-handed melee weapon"],
						type:"weapon",
						subType:"stab",
						damage:2,
						damageType:"melee",
						speed:9,
						autoUse:true,
						showHand:{main:true, off:false},
						maxStack:2,
						size:18,
						itemSize:22,
						tier:1,
						rarity:1
					},
					{
						name:"Bow",
						tooltip:["A basic wooden bow"],
						type:"weapon",
						subType:"shoot",
						damage:10,
						damageType:"ranged",
						speed:9,
						autoUse:false,
						showHand:{main:true, off:true},
						ammoType:"Arrows",
						projectile:"Arrow",
						velocity:0.25,
						maxStack:1,
						size:42,
						itemSize:32,
						tier:1,
						rarity:1
					},
					{
						name:"Laser Gun",
						tooltip:["A quick weapon which shoots bouncing lasers"],
						type:"weapon",
						subType:"shoot",
						damage:10,
						damageType:"magic",
						speed:10,
						autoUse:true,
						showHand:{main:true, off:false},
						useMana:3,
						projectile:"Laser",
						velocity:0.4,
						maxStack:1,
						size:16,
						itemSize:32,
						tier:2,
						rarity:1
					},
					{
						name:"Fire Staff",
						tooltip:["A magical staff that shoots exploding fireballs"],
						type:"weapon",
						subType:"shoot",
						damage:30,
						damageType:"magic",
						speed:30,
						autoUse:false,
						showHand:{main:true, off:false},
						useMana:12,
						projectile:"Fireball",
						velocity:0.15,
						maxStack:1,
						size:19,
						itemSize:38,
						tier:2,
						rarity:1
					},
					{
						name:"Arrows",
						tooltip:["Ammo for use with a bow"],
						type:"ammo",
						damage:5,
						maxStack:30,
						size:15,
						itemSize:30,
						tier:1,
						rarity:1
					},
					{
						name:"Flaming Arrows",
						tooltip:["Has a chance to set the target on fire"],
						type:"ammo",
						damage:6,
						maxStack:30,
						size:14,
						itemSize:28,
						tier:1,
						rarity:1
					},
					{
						name:"Quiver",
						tooltip:["Increases bow firing speed","20% chance to not consume arrows"],
						type:"equipment",
						subType:"back",
						bonus:{},
						maxStack:1,
						size:13,
						itemSize:26,
						tier:2,
						rarity:1
					},
					{
						name:"Backpack",
						tooltip:["Increases inventory space"],
						type:"equipment",
						subType:"back",
						bonus:{},
						maxStack:1,
						tier:2,
						rarity:1
					},
					{
						name:"Boots of Hermes",
						tooltip:["Lets the wearer run very fast"],
						type:"equipment",
						subType:"feet",
						bonus:{armor:1, speed:0, acceleration:0},
						maxStack:1,
						itemSize:34,
						tier:4,
						rarity:2
					},
					{
						name:"Wizard Hat",
						tooltip:["Increases maximum mana","Enables passive mana regeneration"],
						type:"equipment",
						subType:"head",
						bonus:{armor:1, maxMana:10, manaRegen:0.06},
						maxStack:1,
						itemSize:34,
						tier:3,
						rarity:1
					},
					{
						name:"Wizard Robes",
						tooltip:["Increases maximum mana","10% increased magic damage"],
						type:"equipment",
						subType:"body",
						bonus:{armor:2, maxMana:10},
						maxStack:1,
						tier:3,
						rarity:1
					},
					{
						name:"Regeneration Band",
						tooltip:["Increases health regeneration"],
						type:"equipment",
						subType:"arms",
						bonus:{armor:1, regen:0.1},
						maxStack:1,
						itemSize:28,
						tier:4,
						rarity:2
					},
					{
						name:"Gauntlets of Power",
						tooltip:["Increases melee damage",""],
						type:"equipment",
						subType:"hands",
						bonus:{armor:6, damageBonus:0.1},
						maxStack:1,
						tier:4,
						rarity:2
					},
					{
						name:"Chainmail Helmet",
						tooltip:["A strong defensive helmet"],
						type:"equipment",
						subType:"head",
						bonus:{armor:5},
						maxStack:1,
						tier:3,
						rarity:1
					},
					{
						name:"Chainmail Shirt",
						tooltip:[""],
						type:"equipment",
						subType:"body",
						bonus:{armor:8},
						maxStack:1,
						tier:3,
						rarity:1
					},
					{
						name:"Chainmail Leggings",
						tooltip:[""],
						type:"equipment",
						subType:"legs",
						bonus:{armor:6},
						maxStack:1,
						tier:3,
						rarity:1
					},
					{
						name:"Sneaky Cloak",
						tooltip:["Enter stealth mode by holding shift","Stealthy players are invisible and can make sneak attacks"],
						type:"equipment",
						subType:"head",
						bonus:{armor:2, speed:0.1},
						maxStack:1,
						tier:3,
						rarity:1
					},
					{
						name:"Iron Broadsword",
						tooltip:["A powerful, two-handed weapon"],
						type:"weapon",
						subType:"swing",
						damage:3,
						damageType:"melee",
						speed:20,
						autoUse:false,
						showHand:{main:true, off:false},
						maxStack:1,
						size:26,
						itemSize:32,
						tier:3,
						rarity:1
					},
					{
						name:"Tome of Flames",
						tooltip:["Magic Flamethrower"],
						type:"weapon",
						subType:"shoot",
						damage:3,
						damageType:"magic",
						speed:2,
						autoUse:true,
						showHand:{main:true, off:false},
						projectile:"Arrow", //temporary
						velocity:0.25,
						maxStack:1,
						size:26,
						itemSize:34,
						tier:4,
						rarity:2
					},
					{
						name:"Tome of Dragon's Breath",
						tooltip:["Powerful Magic Flamethrower"],
						type:"weapon",
						subType:"shoot",
						damage:8,
						damageType:"magic",
						speed:1,
						autoUse:true,
						showHand:{main:true, off:false},
						maxStack:1,
						size:26,
						itemSize:32,
						tier:5,
						rarity:0  //crafted
					},
					{
						name:"Frost Staff",
						tooltip:["Freezes enemies"],
						type:"weapon",
						subType:"shoot",
						damage:11,
						damageType:"magic",
						speed:7,
						autoUse:true,
						showHand:{main:true, off:false},
						maxStack:1,
						size:26,
						itemSize:32,
						tier:3,
						rarity:0
					}
				];
				armorSet = [
					{
						piece:["Wizard Hat","Wizard Robes"],
						bonus:{maxMana:10, manaRegen:0.04}
					}
				];
				craftingRecipe = [
					{
						ingredients:[
							{
								name:"Tome of Flames",
								count:1
							},
							{
								name:"TBD",
								count:1
							}
						],
						result:{
							name:"Tome of Dragon's Breath",
							count:1
						}
					},
					{
						ingredients:[
							{
								name:"Tome of Flames",
								count:1
							},
							{
								name:"Iron Broadsword",
								count:1
							}
						],
						result:{
							name:"Flaming Broadsword",
							count:1
						}
					},
					{
						ingredients:[
							{
								name:"Tome of Flames",
								count:1
							},
							{
								name:"Boots of Hermes",
								count:1
							}
						],
						result:{
							name:"Magma Boots",
							count:1
						}
					}
				];
				baseProjectile = [
					{
						name:"Base Projctile",
						pos:{x:0, y:0},
						speed:{x:0, y:0},
						damage:0,
						size:10,
						bounces:0,
						pierces:0
					},
					{
						name:"Arrow",
						damage:4,
						size:30
					},
					{
						name:"Fireball"
					},
					{
						name:"Flame"
					}
				];
				baseEnemy = [
					{name:""},
					{
						name:"goblin",
						damage:3,
						weapon:"Rusty Knife",
						size:0.5,
						stat:{
							health:7,
							maxLife:7,
							speed:0.4,
							acceleration:0.02,
							armor:0
						},
						color:{
							body:"#207c1f",
							border:"#124f11"
						}
					}
				];
				baseDust = [
					{
						name:"Orange Number",
						size:15,
						layer:"top"
					},
					{
						name:"Red Number",
						size:15,
						layer:"top"
					},
					{
						name:"Fire"
					},
					{
						name:"Smoke"
					},
					{
						name:"Footstep"
					},
					{
						name:"Magic"
					},
					{
						name:"Fading Arrow",
						rotation:0
					}
				];
			}
			setBaseStats();
			
			var itemIndex = {};
			for(index1 = 0;index1 < item.length;index1++) itemIndex[item[index1].name] = index1;
			
			var sprite = {item:[],projectile:[],empty:{},map:{},other:{}};
			for(index1 = 0;index1 < item.length;index1++){
				var request;
				if(window.XMLHttpRequest)
					request = new XMLHttpRequest();
				else
					request = new ActiveXObject("Microsoft.XMLHTTP");
				request.open('GET', "https://raw.githubusercontent.com/FrogFlint/Roguelike_Resources/master/Item_" + index1 + ".png", false);
				request.send();
				if (request.status == 404) continue;
				//check if expected texture exists
					
				sprite.item[index1] = new Image();
				sprite.item[index1].src = "https://raw.githubusercontent.com/FrogFlint/Roguelike_Resources/master/Item_" + index1 + ".png";
			}
			for(index1 = 1;index1 <= 1;index1++){
				sprite.projectile[index1] = new Image();
				sprite.projectile[index1].src = "https://raw.githubusercontent.com/FrogFlint/Roguelike_Resources/master/Projectile_" + index1 + ".png";
			}
			for(index1 = 0;index1 < equipmentSlots.length;index1++){
				sprite.empty[equipmentSlots[index1]] = new Image();
				sprite.empty[equipmentSlots[index1]].src = "https://raw.githubusercontent.com/FrogFlint/Roguelike_Resources/master/Item_0"/*Empty_" + equipmentSlots[index1]*/ + ".png";
			}
			sprite.other.heart      = new Image();
			sprite.other.heartEmpty = new Image();
			sprite.other.star       = new Image();
			sprite.other.starEmpty  = new Image();
			sprite.other.heart.src      = "https://raw.githubusercontent.com/FrogFlint/Roguelike_Resources/master/Heart.png";
			sprite.other.heartEmpty.src = "https://raw.githubusercontent.com/FrogFlint/Roguelike_Resources/master/EmptyHeart.png";
			sprite.other.star.src       = "https://raw.githubusercontent.com/FrogFlint/Roguelike_Resources/master/Mana.png";
			sprite.other.starEmpty.src  = "https://raw.githubusercontent.com/FrogFlint/Roguelike_Resources/master/EmptyMana.png";
			
			sprite.map.floor = new Image();
			sprite.map.wall = new Image();
			sprite.map.fade = new Image();
			sprite.map.floor.src = "https://raw.githubusercontent.com/FrogFlint/Roguelike_Resources/master/Brick.png";
			sprite.map.wall.src = "https://raw.githubusercontent.com/FrogFlint/Roguelike_Resources/master/Walls.png";
			sprite.map.fade.src = "https://raw.githubusercontent.com/FrogFlint/Roguelike_Resources/master/Fade.png";
			
			var startRoom = [
				["w","w","w","d","w","w","w"],
				["w"," "," "," "," "," ","w"],
				["w"," "," "," "," "," ","w"],
				["w"," "," ","c"," "," ","w"],
				["w"," "," "," "," "," ","w"],
				["w"," "," "," "," "," ","w"],
				["w","w","w","w","w","w","w"]
			];  //Wall, Door, Chest, Ignore
			
			
			
			
			function getMousePos(canvas, evt) {
				var rect = canvas.getBoundingClientRect();
				return {
					x: Math.floor(evt.clientX - rect.left),
					y: Math.floor(evt.clientY - rect.top)
				};
			}
			document.addEventListener("click", onClick, false);
			document.addEventListener("mousemove", onMove, false);
			document.addEventListener("mousedown", function(evt){
				if(mouseControls) mouse = getMousePos(canvas, evt);
				if(event.button == 0) player.key.click = 1;
			}, false);
			document.addEventListener("mouseup", function(evt){
				if(mouseControls) mouse = getMousePos(canvas, evt);
				if(event.button == 0) player.key.click = 0;
			}, false);
			function onClick(evt){
				if(event.button == 0){
					if(gameState == "playing" && playerView == "inventory"){
						mouse = getMousePos(canvas, evt);
						var clicked = inSlot(mouse.x, mouse.y);
						if(!(clicked == false || (typeof clicked == "string" && player.dragItem.subType != clicked && !(player.dragItem.subType == "arms" && (clicked == "arm1" || clicked == "arm2")) && player.dragItem.name != ""))){
							if(typeof clicked == "string") clicked = player.equipment[clicked];
							else clicked = player.inventory[clicked.x][clicked.y];

							var swap = {};
							setProperties(swap, player.dragItem, true);
							setProperties(player.dragItem, clicked, true);
							setProperties(clicked, swap, true);
						}
					}
				}
			}
			function onMove(evt){
				mouse = getMousePos(canvas, evt);
				if(gameState == "playing" && playerView == "game" && mouseControls && player.itemCooldown == 0){
					player.facing = playerIsFacing(mouse.x, mouse.y);
				}
			}
			function playerIsFacing(x, y){
				x -= canvas.width/2;
				y -= canvas.height/2;
				return Math.atan(x / y) + (y >= 0 ? 0 : Math.PI);
			}

			window.oncontextmenu = function(evt){
				if(gameState == "playing" && playerView == "inventory"){
					mouse = getMousePos(canvas, evt);
					var clicked = inSlot(mouse.x, mouse.y);
					if(typeof clicked == "object"){
						clicked = player.inventory[clicked.x][clicked.y];
						if(clicked.type == "equipment"){
							var equip;
							if(clicked.subType == "arms"){
								if(player.equipment.arm1.name != "" && player.equipment.arm2.name == ""){
									equip = player.equipment.arm2;
								}
								else equip = player.equipment.arm1;
							}
							else equip = player.equipment[clicked.subType];
							
							var swap = {};
							setProperties(swap, equip, true);
							setProperties(equip, clicked, true);
							setProperties(clicked, swap, true);
						}
					}
				}
				
				return false;
			}
			
			
			
			
			function buildRoom(x, y, maxSize = 14, doors = 13, chests = 0, enemies = 2){  //random generation
				if(map[x][y].object != "door") return false;
				
				
				var entrance = "";
				var roomDirection = "";
				     if(!map[x + 1][y].discovered) x++;
				else if(!map[x - 1][y].discovered) x--;
				else if(!map[x][y + 1].discovered) y++;
				else if(!map[x][y - 1].discovered) y--;
				//if(roomDirection == "") return false;
				
				var doorSide = {top:false,bottom:false,left:false,right:false};
				doorSide[roomDirection] = true;
				
				
				var index3, index4;
				var noRoom = false;/*
				for(var size = 7;size <= maxSize && !noRoom;size++){
					if(roomDirection == "left"){
						for(index3 = x - size;index3 <= x;index3++){
							for(index4 = y - Math.floor(size/2);index4 <= y + Math.floor(size/2);index4++){
								if(!(index3 == x && index4 == y) && !map[index3][index4].wall) noRoom = true;
							}
						}
						for(index3 = x - size - 3;index3 <= x + 3;index3++){
							for(index4 = y - Math.floor(size/2);index4 <= y + Math.floor(size/2) + 6;index4++){
								if(!(index3 == x && index4 == y) && map[index3][index4].object == "door" && map[index3][index4].rotation == 0 && !map[index3][index4 - 1].discovered) noRoom = true;
							}
						}
						for(index3 = x - size - 3;index3 <= x + 3;index3++){
							for(index4 = y - Math.floor(size/2) - 6;index4 <= y + Math.floor(size/2);index4++){
								if(!(index3 == x && index4 == y) && map[index3][index4].object == "door" && map[index3][index4].rotation == 0 && !map[index3][index4 + 1].discovered) noRoom = true;
							}
						}
						for(index3 = x - size;index3 <= x + 6;index3++){
							for(index4 = y - Math.floor(size/2) - 3;index4 <= y + Math.floor(size/2) + 3;index4++){
								if(!(index3 == x && index4 == y) && map[index3][index4].object == "door" && map[index3][index4].rotation == 1 && !map[index3 - 1][index4].discovered) noRoom = true;
							}
						}
						for(index3 = x - size - 6;index3 <= x;index3++){
							for(index4 = y - Math.floor(size/2) - 3;index4 <= y + Math.floor(size/2) + 3;index4++){
								if(!(index3 == x && index4 == y) && map[index3][index4].object == "door" && map[index3][index4].rotation == 1 && !map[index3 + 1][index4].discovered) noRoom = true;
							}
						}
					}
					if(roomDirection == "right"){
						for(index3 = x + size;index3 >= x;index3--){
							for(index4 = y - Math.floor(size/2);index4 <= y + Math.floor(size/2);index4++){
								if(!(index3 == x && index4 == y) && !map[index3][index4].wall) noRoom = true;
							}
						}
						for(index3 = x + size + 3;index3 >= x - 3;index3--){
							for(index4 = y - Math.floor(size/2);index4 <= y + Math.floor(size/2) + 6;index4++){
								if(!(index3 == x && index4 == y) && map[index3][index4].object == "door" && map[index3][index4].rotation == 0 && !map[index3][index4 - 1].discovered) noRoom = true;
							}
						}
						for(index3 = x + size + 3;index3 >= x - 3;index3--){
							for(index4 = y - Math.floor(size/2) - 6;index4 <= y + Math.floor(size/2);index4++){
								if(!(index3 == x && index4 == y) && map[index3][index4].object == "door" && map[index3][index4].rotation == 0 && !map[index3][index4 + 1].discovered) noRoom = true;
							}
						}
						for(index3 = x + size + 6;index3 >= x;index3--){
							for(index4 = y - Math.floor(size/2) - 3;index4 <= y + Math.floor(size/2) + 3;index4++){
								if(!(index3 == x && index4 == y) && map[index3][index4].object == "door" && map[index3][index4].rotation == 1 && !map[index3 - 1][index4].discovered) noRoom = true;
							}
						}
						for(index3 = x + size;index3 >= x - 6;index3--){
							for(index4 = y - Math.floor(size/2) - 3;index4 <= y + Math.floor(size/2) + 3;index4++){
								if(!(index3 == x && index4 == y) && map[index3][index4].object == "door" && map[index3][index4].rotation == 1 && !map[index3 + 1][index4].discovered) noRoom = true;
							}
						}
					}
					if(roomDirection == "top"){
						for(index3 = x - Math.floor(size/2);index3 <= x + Math.floor(size/2);index3++){
							for(index4 = y - size;index4 <= y;index4++){
								if(!(index3 == x && index4 == y) && !map[index3][index4].wall) noRoom = true;
							}
						}
						for(index3 = x - Math.floor(size/2) - 3;index3 <= x + Math.floor(size/2) + 3;index3++){
							for(index4 = y - size;index4 <= y + 6;index4++){
								if(!(index3 == x && index4 == y) && map[index3][index4].object == "door" && map[index3][index4].rotation == 0 && !map[index3][index4 - 1].discovered) noRoom = true;
							}
						}
						for(index3 = x - Math.floor(size/2) - 3;index3 <= x + Math.floor(size/2) + 3;index3++){
							for(index4 = y - size - 6;index4 <= y;index4++){
								if(!(index3 == x && index4 == y) && map[index3][index4].object == "door" && map[index3][index4].rotation == 0 && !map[index3][index4 + 1].discovered) noRoom = true;
							}
						}
						for(index3 = x - Math.floor(size/2);index3 <= x + Math.floor(size/2) + 6;index3++){
							for(index4 = y - size - 3;index4 <= y + 3;index4++){
								if(!(index3 == x && index4 == y) && map[index3][index4].object == "door" && map[index3][index4].rotation == 1 && !map[index3 - 1][index4].discovered) noRoom = true;
							}
						}
						for(index3 = x - Math.floor(size/2) - 6;index3 <= x + Math.floor(size/2);index3++){
							for(index4 = y - size - 3;index4 <= y + 3;index4++){
								if(!(index3 == x && index4 == y) && map[index3][index4].object == "door" && map[index3][index4].rotation == 1 && !map[index3 + 1][index4].discovered) noRoom = true;
							}
						}
					}
					if(roomDirection == "bottom"){
						for(index3 = x - Math.floor(size/2);index3 <= x + Math.floor(size/2);index3++){
							for(index4 = y + size;index4 >= y;index4--){
								if(!(index3 == x && index4 == y) && !map[index3][index4].wall) noRoom = true;
							}
						}
						for(index3 = x - Math.floor(size/2) - 3;index3 <= x + Math.floor(size/2) + 3;index3++){
							for(index4 = y + size + 6;index4 >= y - 6;index4--){
								if(!(index3 == x && index4 == y) && map[index3][index4].object == "door" && map[index3][index4].rotation == 0) noRoom = true;
							}
						}
						for(index3 = x - Math.floor(size/2) - 6;index3 <= x + Math.floor(size/2) + 6;index3++){
							for(index4 = y + size + 3;index4 >= y - 3;index4--){
								if(!(index3 == x && index4 == y) && map[index3][index4].object == "door" && map[index3][index4].rotation == 1) noRoom = true;
							}
						}
					}
					
					if(noRoom) size--;
				}*/
				
				var extend = {};
				for(index3 = 0;!(map[x + index3][y].wall || map[x + index3][y].object == "door");index3++) extend.right = index3;
				for(index3 = 0;!(map[x - index3][y].wall || map[x - index3][y].object == "door");index3++) extend.left = index3;
				for(index3 = 0;!(map[x][y + index3].wall || map[x][y + index3].object == "door");index3++) extend.bottom = index3;
				for(index3 = 0;!(map[x][y - index3].wall || map[x][y - index3].object == "door");index3++) extend.top = index3;
				
				
				//for(index3 = 0;index3 < 4;index3++){
				//	extend[edgeDirection[index3]] = entrance == edgeDirection[index3] ? 0 : Math.floor(/*randRange(randRange(*/(size - 1)/*, 6), 6)*//(roomDirection == edgeDirection[index3] ? 1 : 2));
				//}
				var boundaries = {left:x - extend.left - 1, right:x + extend.right + 1, top:y - extend.top - 1, bottom:y + extend.bottom + 1};
				//for(index3 = 0;index3 < 4;index3++){
				//	boundaries[edgeDirection[index3]] = (index3 < 2 ? y:x) + extend[edgeDirection[index3]]*(index3 % 2 == 0 ? -1:1);
				//}
				for(index3 = boundaries.left;index3 <= boundaries.right;index3++){
					for(index4 = boundaries.top;index4 <= boundaries.bottom;index4++){
						map[index3][index4].discovered = true;
					}
				}
				
				var done = false;
				while(!done){
					done = true;
					
					for(index3 = boundaries.left - 1;index3 <= boundaries.right + 1;index3 += boundaries.right - boundaries.left + 2){
						for(index4 = boundaries.top - 1;index4 <= boundaries.bottom + 1;index4++){
							if(!map[index3][index4].discovered && map[index3][index4].wall && map[index3 + 2][index4].wall + map[index3 - 2][index4].wall + map[index3][index4 + 2].wall + map[index3][index4 - 2].wall <= 2){
								roomShape(index3, index4);
								done = false;
							}
						}
					}
					for(index4 = boundaries.top - 1;index4 <= boundaries.bottom + 1;index4 += boundaries.bottom - boundaries.top + 2){
						for(index3 = boundaries.left - 1;index3 <= boundaries.right + 1;index3++){
							if(!map[index3][index4].discovered && map[index3][index4].wall && map[index3 + 2][index4].wall + map[index3 - 2][index4].wall + map[index3][index4 + 2].wall + map[index3][index4 - 2].wall <= 2){
								roomShape(index3, index4);
								done = false;
							}
						}
					}
				}
				
				
				var doorCount = 1;
				var giveUp = false;
				tried = [];
				for(index3 = 0;index3 <= boundaries.right - boundaries.left;index3++){
					tried[index3] = [];
					for(index4 = 0;index4 <= boundaries.bottom - boundaries.top;index4++){
						tried[index3][index4] = false;
					}
				}
				var rand = {x:boundaries.left, y:boundaries.top};
				/*while(doorCount < doors && !giveUp){
					while(tried[rand.x - boundaries.left][rand.y - boundaries.top]){
						rand = {x:Math.floor(Math.random()*(boundaries.right - boundaries.left + 1) + boundaries.left), y:Math.floor(Math.random()*(boundaries.bottom - boundaries.top + 1) + boundaries.top)};
					}
					if(map[rand.x][rand.y].wall && map[rand.x - 1][rand.y].wall + map[rand.x + 1][rand.y].wall + map[rand.x][rand.y - 1].wall + map[rand.x][rand.y + 1].wall == 3){
						if(!(map[rand.x - 1][rand.y].wall || doorSide.left)){
							noRoom = false;
							for(index3 = rand.x + 6;index3 >= rand.x;index3--){
								for(index4 = rand.y - 3;index4 <= rand.y + 3;index4++){
									if(!map[index3][index4].wall) noRoom = true;
								}
							}
							for(index3 = rand.x + 6 + 3;index3 >= rand.x - 3;index3--){
								for(index4 = rand.y - 3 - 6;index4 <= rand.y + 3 + 6;index4++){
									if(!(index3 == x && index4 == y) && map[index3][index4].object == "door" && map[index3][index4].rotation == 0) noRoom = true;
								}
							}
							for(index3 = rand.x + 6 + 6;index3 >= rand.x - 6;index3--){
								for(index4 = rand.y - 3 - 3;index4 <= rand.y + 3 + 3;index4++){
									if(!(index3 == x && index4 == y) && map[index3][index4].object == "door" && map[index3][index4].rotation == 1) noRoom = true;
								}
							}
							if(!noRoom){
								map[rand.x][rand.y].wall = false;
								map[rand.x][rand.y].object = "door";
								map[rand.x][rand.y].rotation = 1;
								doorCount++;
							}
						}
						if(!(map[rand.x + 1][rand.y].wall || doorSide.right)){
							noRoom = false;
							for(index3 = rand.x - 6;index3 <= rand.x;index3++){
								for(index4 = rand.y - 3;index4 <= rand.y + 3;index4++){
									if(!map[index3][index4].wall) noRoom = true;
								}
							}
							for(index3 = rand.x - 6 - 3;index3 <= rand.x + 3;index3++){
								for(index4 = rand.y - 3 - 6;index4 <= rand.y + 3 + 6;index4++){
									if(!(index3 == x && index4 == y) && map[index3][index4].object == "door" && map[index3][index4].rotation == 0) noRoom = true;
								}
							}
							for(index3 = rand.x - 6 - 6;index3 <= rand.x + 6;index3++){
								for(index4 = rand.y - 3 - 3;index4 <= rand.y + 3 + 3;index4++){
									if(!(index3 == x && index4 == y) && map[index3][index4].object == "door" && map[index3][index4].rotation == 1) noRoom = true;
								}
							}
							if(!noRoom){
								map[rand.x][rand.y].wall = false;
								map[rand.x][rand.y].object = "door";
								map[rand.x][rand.y].rotation = 1;
								doorCount++;
							}
						}
						if(!(map[rand.x][rand.y - 1].wall || doorSide.top)){
							noRoom = false;
							for(index3 = rand.x - 3;index3 <= rand.x + 3;index3++){
								for(index4 = rand.y + 6;index4 >= rand.y;index4--){
									if(!map[index3][index4].wall) noRoom = true;
								}
							}
							for(index3 = rand.x - 3 - 3;index3 <= rand.x + 3 + 3;index3++){
								for(index4 = rand.y + 6 + 6;index4 >= rand.y - 6;index4--){
									if(!(index3 == x && index4 == y) && map[index3][index4].object == "door" && map[index3][index4].rotation == 0) noRoom = true;
								}
							}
							for(index3 = rand.x - 3 - 6;index3 <= rand.x + 3 + 6;index3++){
								for(index4 = rand.y + 6 + 3;index4 >= rand.y - 3;index4--){
									if(!(index3 == x && index4 == y) && map[index3][index4].object == "door" && map[index3][index4].rotation == 1) noRoom = true;
								}
							}
							if(!noRoom){
								map[rand.x][rand.y].wall = false;
								map[rand.x][rand.y].object = "door";
								map[rand.x][rand.y].rotation = 0;
								doorCount++;
							}
						}
						if(!(map[rand.x][rand.y + 1].wall || doorSide.bottom)){
							noRoom = false;
							for(index3 = rand.x - 3;index3 <= rand.x + 3;index3++){
								for(index4 = rand.y - 6;index4 <= rand.y;index4++){
									if(!map[index3][index4].wall) noRoom = true;
								}
							}
							for(index3 = rand.x - 3 - 3;index3 <= rand.x + 3 + 3;index3++){
								for(index4 = rand.y - 6 - 6;index4 <= rand.y + 6;index4++){
									if(!(index3 == x && index4 == y) && map[index3][index4].object == "door" && map[index3][index4].rotation == 0) noRoom = true;
								}
							}
							for(index3 = rand.x - 3 - 6;index3 <= rand.x + 3 + 6;index3++){
								for(index4 = rand.y - 6 - 3;index4 <= rand.y + 3;index4++){
									if(!(index3 == x && index4 == y) && map[index3][index4].object == "door" && map[index3][index4].rotation == 1) noRoom = true;
								}
							}
							if(!noRoom){
								map[rand.x][rand.y].wall = false;
								map[rand.x][rand.y].object = "door";
								map[rand.x][rand.y].rotation = 0;
								doorCount++;
							}
						}
					}
					tried[rand.x - boundaries.left][rand.y - boundaries.top] = true;
					giveUp = true;
					for(index3 = 0;index3 < tried.length;index3++){
						for(index4 = 0;index4 < tried[index3].length;index4++){
							if(!tried[index3][index4]) giveUp = false;
						}
					}
				}*/
				
				for(index3 = boundaries.left;index3 <= boundaries.right;index3++){
					for(index4 = boundaries.top;index4 <= boundaries.bottom;index4++){
						/*if(!map[index3][index4].wall) */map[index3][index4].discovered = true;
					}
				}
				
				while(enemies > 0){
					var rand = {x:Math.floor(Math.random()*(boundaries.right - boundaries.left) + boundaries.left), y:Math.floor(Math.random()*(boundaries.bottom - boundaries.top) + boundaries.top)};
					if(!map[rand.x][rand.y].wall && map[rand.x][rand.y].object == ""){
						var type = 1; //generate randomly
						var newEnemy = enemy[getNext(enemy)];
						setProperties(newEnemy, baseEnemy[type], true);
						setProperties(newEnemy, {pos:{x:rand.x + 0.5, y:rand.y + 0.5},speed:{x:0,y:0},active:true, maxHealth:newEnemy.health});
						
						enemies--;
					}
				}
			}
			
			function roomShape(x, y, maxSize = 14){
				var extend = {up:0,down:0,left:0,right:0};
				var size = Math.floor(Math.random()*(maxSize - 6)) + 6;
				var noRoom = false;
				var stop = false;
				
				while(!stop){
					stop = true;
					
					if(extend.left + extend.right < maxSize){
						noRoom = false;
						for(var index3 = y - extend.up;index3 <= y + extend.down;index3++){
							if(!(map[x - extend.left - 1][index3].wall || map[x - extend.left - 1][index3].object == "door")) noRoom = true;
						}
						if(!noRoom){
							extend.left++;
							stop = false;
						}
						noRoom = false;
						for(var index3 = y - extend.up;index3 <= y + extend.down;index3++){
							if(!(map[x + extend.right + 1][index3].wall || map[x + extend.right + 1][index3].object == "door")) noRoom = true;
						}
						if(!noRoom){
							extend.right++;
							stop = false;
						}
					}
					if(extend.up + extend.down < maxSize){
						noRoom = false;
						for(var index3 = x - extend.left;index3 <= x + extend.right;index3++){
							if(!(map[index3][y - extend.up - 1].wall || map[index3][y - extend.up - 1].object == "door")) noRoom = true;
						}
						if(!noRoom){
							extend.up++;
							stop = false;
						}
						noRoom = false;
						for(var index3 = x - extend.left;index3 <= x + extend.right;index3++){
							if(!(map[index3][y + extend.down + 1].wall || map[index3][y + extend.down + 1].object == "door")) noRoom = true;
						}
						if(!noRoom){
							extend.down++;
							stop = false;
						}
					}
				}
				
				extend.up = Math.floor(Math.random()*(extend.up - Math.min(Math.max(6 - extend.down, 1), extend.up))) + Math.min(Math.max(6 - extend.down, 1), extend.up);
				extend.down = Math.floor(Math.random()*(extend.down - Math.min(Math.max(6 - extend.up, 1), extend.down))) + Math.min(Math.max(6 - extend.up, 1), extend.down);
				extend.left = Math.floor(Math.random()*(extend.left - Math.min(Math.max(6 - extend.right, 1), extend.left))) + Math.min(Math.max(6 - extend.right, 1), extend.left);
				extend.right = Math.floor(Math.random()*(extend.right - Math.min(Math.max(6 - extend.left, 1), extend.right))) + Math.min(Math.max(6 - extend.left, 1), extend.right);
				
				for(var index3 = x - extend.left;index3 <= x + extend.right;index3++){
					for(var index4 = y - extend.up;index4 <= y + extend.down;index4++){
						map[index3][index4].wall = map[index3][index4].object != "door" && (index3 == x - extend.left || index3 == x + extend.right || index4 == y - extend.up || index4 == y + extend.down);
						//map[index3][index4].discovered = true; //temp
					}
				}
			}
			
			function addDoors(x, y){}
			
			function makeRoom(plan, x, y){  //plan is a 2D array
				for(var index4 = 0;index4 < plan.length;index4++){
					for(var index3 = 0;index3 < plan[index4].length;index3++){
						if(!(plan[index4][index3] == "w" || plan[index4][index3] == "i")){
							map[x + index3][y + index4].wall = false;
						}
						if(plan[index4][index3] == "d"){
							map[x + index3][y + index4].object = "door";
							map[x + index3][y + index4].open = false;
							
						}
						if(plan[index4][index3] == "c"){
							map[x + index3][y + index4].object = "chest";
							map[x + index3][y + index4].open = false;
						}
						map[x + index3][y + index4].discovered = true;
					}
				}
			}
			
			
			function updatePlayerStats(){
				setProperties(player.stat, {
					maxLife:80,
					maxMana:10,
					speed:0.2,
					acceleration:0.03,
					regen:0.06,
					manaRegen:0.03,
					armor:0,
					damageBonus:0
				});
				for(index1 = 0;index1 < equipmentSlots.length;index1++){
					if(player.equipment[equipmentSlots[index1]].name != ""){
						var changeStat = Object.getOwnPropertyNames(player.equipment[equipmentSlots[index1]].bonus);
						for(index2 = 0;index2 < changeStat.length;index2++){
							player.stat[changeStat[index2]] += player.equipment[equipmentSlots[index1]].bonus[changeStat[index2]];
						}
					}
				}
				
				
				player.stat.health = Math.min(player.stat.health + (playerView == "game" ? player.stat.regen : 0), player.stat.maxLife);
				player.stat.mana = Math.min(player.stat.mana + (playerView == "game" ? player.stat.manaRegen : 0), player.stat.maxMana);
			}
			function applyEffects(){}
			
			function movePlayer(){
				if(player.itemCooldown > 0) player.itemCooldown--;
				if(player.itemCooldown == 0 && player.key.click == 1){
					player.facing = playerIsFacing(mouse.x, mouse.y);
					useItem(player, player.inventory[player.slot][0]);
					if(player.inventory[player.slot][0].autoUse != true) player.key.click = 2;
				}
				
				var stopped = player.speed.x == 0 && player.speed.y == 0;
				
				if(player.key.left ) player.speed.x -= player.stat.acceleration;
				if(player.key.right) player.speed.x += player.stat.acceleration;
				if(player.key.up   ) player.speed.y -= player.stat.acceleration;
				if(player.key.down ) player.speed.y += player.stat.acceleration;
				
				if(!(mouseControls || stopped || (player.speed.x == 0 && player.speed.y == 0))) player.facing = playerIsFacing(canvas.width/2 + player.speed.x, canvas.height/2 + player.speed.y);
				
				if(!(player.key.left || player.key.right || player.speed.x == 0)) player.speed.x += player.stat.acceleration * (player.speed.x > 0 ? -1 : 1);
				if(!(player.key.up   || player.key.down  || player.speed.y == 0)) player.speed.y += player.stat.acceleration * (player.speed.y > 0 ? -1 : 1);
				
				if(Math.abs(player.speed.x) < player.stat.acceleration) player.speed.x = 0;
				if(Math.abs(player.speed.y) < player.stat.acceleration) player.speed.y = 0;
				
				player.speed.x = Math.max(Math.min(player.speed.x, player.stat.speed), -player.stat.speed);
				player.speed.y = Math.max(Math.min(player.speed.y, player.stat.speed), -player.stat.speed);
				player.pos.x += player.speed.x;
				player.pos.y += player.speed.y;
				
				
				if(!map[Math.floor(player.pos.x)][Math.floor(player.pos.y)].wall){
					//wall side
					var bounce = wallCollisions(player.pos.x, player.pos.y, player.size/2);
					player.pos.x = bounce.x;
					player.pos.y = bounce.y;
					if(bounce.left || bounce.right) player.speed.x = 0;
					if(bounce.up   || bounce.down ) player.speed.y = 0;
					//door
					if(map[Math.floor(player.pos.x - player.size/2)][Math.floor(player.pos.y)].object == "door" &&
					  !map[Math.floor(player.pos.x - player.size/2)][Math.floor(player.pos.y)].open &&
					   map[Math.floor(player.pos.x - player.size/2)][Math.floor(player.pos.y)].rotation % 2 == 1 &&
					  (player.pos.x - player.size/2) % 1 < 3/5){
						player.pos.x = Math.floor(player.pos.x - player.size/2) + 3/5 + player.size/2;
					}
					if(map[Math.floor(player.pos.x + player.size/2)][Math.floor(player.pos.y)].object == "door" &&
					  !map[Math.floor(player.pos.x + player.size/2)][Math.floor(player.pos.y)].open &&
					   map[Math.floor(player.pos.x + player.size/2)][Math.floor(player.pos.y)].rotation % 2 == 1 &&
					  (player.pos.x + player.size/2) % 1 > 2/5){
						player.pos.x = Math.floor(player.pos.x + player.size/2) + 2/5 - player.size/2 - 0.0001;
					}
					if(map[Math.floor(player.pos.x)][Math.floor(player.pos.y - player.size/2)].object == "door" &&
					  !map[Math.floor(player.pos.x)][Math.floor(player.pos.y - player.size/2)].open &&
					   map[Math.floor(player.pos.x)][Math.floor(player.pos.y - player.size/2)].rotation % 2 == 0 &&
					  (player.pos.y - player.size/2) % 1 < 3/5){
						player.pos.y = Math.floor(player.pos.y - player.size/2) + 3/5 + player.size/2;
					}
					if(map[Math.floor(player.pos.x)][Math.floor(player.pos.y + player.size/2)].object == "door" &&
					  !map[Math.floor(player.pos.x)][Math.floor(player.pos.y + player.size/2)].open &&
					   map[Math.floor(player.pos.x)][Math.floor(player.pos.y + player.size/2)].rotation % 2 == 0 &&
					  (player.pos.y + player.size/2) % 1 > 2/5){
						player.pos.y = Math.floor(player.pos.y + player.size/2) + 2/5 - player.size/2 - 0.0001;
					}
				}
			}
			function moveEnemies(){}
			function moveProjectiles(){
				for(index1 = 0;index1 < 2;index1++){
					for(index2 = 0;index2 < projectileCap;index2++){
						var proj = projectile[projOwner[index1]][index2];
						if(proj.active){
							proj.pos.x += proj.speed.x;
							proj.pos.y += proj.speed.y;
							
							var bounce = wallCollisions(proj.pos.x, proj.pos.y, proj.size/2 / tileSize);
							
							proj.pos.x = bounce.x;
							proj.pos.y = bounce.y;
							
							if(bounce.left || bounce.right || bounce.up || bounce.down || bounce.upLeft || bounce.upRight || bounce.downLeft || bounce.downRight){
								if(true){
									proj.active = false;
								}
							}
						}
					}
				}
			}
			function meleeAttacks(){}
			function moveDust(){}
			
			function killStuff(){}
			
			function wallCollisions(x, y, size){
				var collisions = {x:x, y:y, up:false, down:false, left:false, right:false, upLeft:false, upRight:false, downLeft:false, downRight:false};
				if(!map[Math.floor(x)][Math.floor(y)].wall){
					if(map[Math.floor(x - size)][Math.floor(y)].wall){
						x = Math.floor(x) + size;
						collisions.left = true;
					}
					if(map[Math.floor(x + size)][Math.floor(y)].wall){
						x = Math.floor(x) - size + 0.9999;
						collisions.right = true;
					}
					if(map[Math.floor(x)][Math.floor(y - size)].wall){
						y = Math.floor(y) + size;
						collisions.up = true;
					}
					if(map[Math.floor(x)][Math.floor(y + size)].wall){
						y = Math.floor(y) - size + 0.9999;
						collisions.down = true;
					}
					if(map[Math.floor(x - size)][Math.floor(y - size)].wall){
						var cornerDistance = distance(x - Math.floor(x), y - Math.floor(y));
						if(cornerDistance < size){
							x = Math.floor(x) + ((x - Math.floor(x)) * (size)/cornerDistance);
							y = Math.floor(y) + ((y - Math.floor(y)) * (size)/cornerDistance);
							collisions.upLeft = true;
						}
					}
					if(map[Math.floor(x + size)][Math.floor(y - size)].wall){
						var cornerDistance = distance(x - Math.ceil(x), y - Math.floor(y));
						if(cornerDistance < size){
							x = Math.ceil (x) + ((x - Math.ceil (x)) * (size)/cornerDistance);
							y = Math.floor(y) + ((y - Math.floor(y)) * (size)/cornerDistance);
							collisions.upRight = true;
						}
					}
					if(map[Math.floor(x - size)][Math.floor(y + size)].wall){
						var cornerDistance = distance(x - Math.floor(x), y - Math.ceil (y));
						if(cornerDistance < size){
							x = Math.floor(x) + ((x - Math.floor(x)) * (size)/cornerDistance);
							y = Math.ceil (y) + ((y - Math.ceil (y)) * (size)/cornerDistance);
							collisions.downLeft = true;
						}
					}
					if(map[Math.floor(x + size)][Math.floor(y + size)].wall){
						var cornerDistance = distance(x - Math.ceil (x), y - Math.ceil (y));
						if(cornerDistance < size){
							x = Math.ceil (x) + ((x - Math.ceil (x)) * (size)/cornerDistance);
							y = Math.ceil (y) + ((y - Math.ceil (y)) * (size)/cornerDistance);
							collisions.downRight = true;
						}
					}
					
					collisions.x = x;
					collisions.y = y;
				}
				
				return collisions;
			}
			
			function useItem(user, usedItem){
				if(usedItem.type == "weapon"){
					user.itemCooldown = usedItem.speed;
					if(usedItem.subType == "shoot"){
						var shot = getNext(projectile.player);
						var r = usedItem.name == "Tome of Flames" ? Math.random()*0.8 - 0.4 : 0;
						projectile.player[shot] = {
							type:usedItem.projectile,
							active:true,
							pos:{
								x:user.pos.x,
								y:user.pos.y
							},
							speed:{
								x:player.speed.x/10 + Math.sin(user.facing + r) * usedItem.velocity,
								y:player.speed.y/10 + Math.cos(user.facing + r) * usedItem.velocity
							}
						}
						setProperties(projectile.player[shot], baseProjectile[1]);
					}
					
				}
			}
			function getNext(list){
				for(var index5 = 0;index5 < list.length;index5++){
					if(list[index5].length < 2 || list[index5].type == "" || list[index5].active == false) return index5;
				}
				return false;
			}
			function inSlot(x, y){
				if(x >= 20 && x <= 70*inventorySize.width && y >= 20 && y <= 70*inventorySize.height){
					if((x - 20) % 70 <= 50 && (y - 20) % 70 <= 50){
						return {x:Math.floor((x - 20)/70),y:Math.floor((y - 20)/70)};
					}
				}
				for(index1 = 0;index1 < equipmentSlots.length;index1++){
					if(x >= equipmentSlotLocation[index1].x && x <= equipmentSlotLocation[index1].x + 50 && y >= equipmentSlotLocation[index1].y && y <= equipmentSlotLocation[index1].y + 50){
						return equipmentSlots[index1];
					}
				}
				return false;
			}
			
			
			function drawMap(){
				for(index1 = Math.max(mapEdge.left, Math.floor(player.pos.x - (canvas.width/2)/tileSize));index1 <= Math.min(mapEdge.right, Math.ceil(player.pos.x + (canvas.width/2)/tileSize));index1++){
					for(index2 = Math.max(mapEdge.top, Math.floor(player.pos.y - (canvas.height/2)/tileSize));index2 <= Math.min(mapEdge.bottom, Math.ceil(player.pos.y + (canvas.height/2)/tileSize));index2++){
						if(map[index1][index2].discovered){
							drawPos = {x:canvas.width/2 + Math.round((index1 - player.pos.x)*tileSize), y:canvas.height/2 + Math.round((index2 - player.pos.y)*tileSize)};
							if(!map[index1][index2].wall){
								drawSprite("map", "floor", drawPos.x, drawPos.y, tileSize);
							}
							else{
								var selectedSprite = wallSprite(!map[index1-1][index2-1].wall, !map[index1][index2-1].wall, !map[index1+1][index2-1].wall, !map[index1-1][index2].wall, !map[index1+1][index2].wall, !map[index1-1][index2+1].wall, !map[index1][index2+1].wall, !map[index1+1][index2+1].wall);
								drawSprite("map", "wall", drawPos.x, drawPos.y, tileSize, selectedSprite.x, selectedSprite.y);
								drawFade(index1, index2);
							}
							if(map[index1][index2].object == "door"){
								if(map[index1][index2].open){
									if(map[index1][index2].rotation % 2 == 0){
										ctx.beginPath();
										ctx.fillStyle = "#772600";
										ctx.fillRect(drawPos.x, drawPos.y, tileSize*1/5, tileSize*3/5);
										ctx.fillRect(drawPos.x + tileSize*4/5, drawPos.y, tileSize*1/5, tileSize*3/5);
										ctx.closePath();
									}
									else{
										ctx.beginPath();
										ctx.fillStyle = "#772600";
										ctx.fillRect(drawPos.x, drawPos.y, tileSize*3/5, tileSize*1/5);
										ctx.fillRect(drawPos.x, drawPos.y + tileSize*4/5, tileSize*3/5, tileSize*1/5);
										ctx.closePath();
									}
								}
								else{
									if(map[index1][index2].rotation % 2 == 0){
										if(!map[index1][index2 - 1].discovered){
											ctx.beginPath();
											ctx.fillStyle = "Black";
											ctx.fillRect(drawPos.x, drawPos.y, tileSize, tileSize/2);
											ctx.closePath();
										}
										if(!map[index1][index2 + 1].discovered){
											ctx.beginPath();
											ctx.fillStyle = "Black";
											ctx.fillRect(drawPos.x, drawPos.y + tileSize/2, tileSize, tileSize/2);
											ctx.closePath();
										}
										ctx.beginPath();
										ctx.fillStyle = "#772600";
										ctx.fillRect(drawPos.x, drawPos.y + tileSize*2/5, tileSize, tileSize*1/5);
										ctx.closePath();
									}
									else{
										if(!map[index1 - 1][index2].discovered){
											ctx.beginPath();
											ctx.fillStyle = "Black";
											ctx.fillRect(drawPos.x, drawPos.y, tileSize/2, tileSize);
											ctx.closePath();
										}
										if(!map[index1 + 1][index2].discovered){
											ctx.beginPath();
											ctx.fillStyle = "Black";
											ctx.fillRect(drawPos.x + tileSize/2, drawPos.y, tileSize/2, tileSize);
											ctx.closePath();
										}
										ctx.beginPath();
										ctx.fillStyle = "#772600";
										ctx.fillRect(drawPos.x + tileSize*2/5, drawPos.y, tileSize*1/5, tileSize);
										ctx.closePath();
									}
								}
							}
						}
					}
				}
			}
			function drawPlayer(){
				ctx.beginPath();
				ctx.arc(canvas.width/2, canvas.height/2, tileSize * player.size/2 - 1, 0, Math.PI*2);
				ctx.fillStyle = "#8a2c00";
				ctx.fill();
				ctx.lineWidth = 2;
				ctx.strokeStyle = "#6e2300";
				ctx.stroke();
				ctx.closePath();
			}
			function drawEnemies(){
				for(index1 = 0;index1 < enemyCap;index1++){
					if(enemy[index1].active){
						ctx.beginPath();
						ctx.arc(canvas.width/2 + (enemy[index1].pos.x - player.pos.x)*tileSize, canvas.height/2 + (enemy[index1].pos.y - player.pos.y)*tileSize, tileSize*enemy[index1].size/2, 0, Math.PI*2);
						ctx.fillStyle = enemy[index1].color.body;
						ctx.fill();
						ctx.lineWidth = 2;
						ctx.strokeStyle = enemy[index1].color.border;
						ctx.stroke();
						ctx.closePath();
					}
				}
			}
			function drawProjectiles(){
				for(index1 = 0;index1 < 2;index1++){
					for(index2 = 0;index2 < projectileCap;index2++){
						var proj = projectile[projOwner[index1]][index2];
						if(proj.active){
							drawSprite("projectile", 1, canvas.width/2 + (proj.pos.x - player.pos.x)*tileSize - proj.size/2, canvas.height/2 + (proj.pos.y - player.pos.y)*tileSize - proj.size/2, proj.size, Math.atan(proj.speed.y / proj.speed.x) + (proj.speed.x >= 0 ? 0 : Math.PI) + Math.PI/2);
						}
					}
				}
			}
			function drawWeapons(){
				if(player.itemCooldown > 0){
					var swingAngle = player.facing;
					
					if(player.inventory[player.slot][0].subType == "swing"){
						swingAngle += 1 - 2.5*player.itemCooldown/player.inventory[player.slot][0].speed;
						drawSprite("item", player.inventory[player.slot][0].name, canvas.width/2 + Math.sin(swingAngle - 0.75)*tileSize*0.5 - player.inventory[player.slot][0].size*1.5*0.85, canvas.height/2 + Math.cos(swingAngle - 0.75)*tileSize*0.5 - player.inventory[player.slot][0].size*1.5*0.15, player.inventory[player.slot][0].size*1.5, Math.PI*0.7 - swingAngle, player.inventory[player.slot][0].size*1.5*0.85, player.inventory[player.slot][0].size*1.5*0.15);
					}
					if(player.inventory[player.slot][0].subType == "stab"){
						swingAngle += 0.3 - 2*player.itemCooldown/player.inventory[player.slot][0].speed;
						drawSprite("item", player.inventory[player.slot][0].name, canvas.width/2 + Math.sin(swingAngle - 0.75)*tileSize*0.5 - player.inventory[player.slot][0].size*1.5*0.85, canvas.height/2 + Math.cos(swingAngle - 0.75)*tileSize*0.5 - player.inventory[player.slot][0].size*1.5*0.15, player.inventory[player.slot][0].size*1.5, Math.PI*0.6 - swingAngle - 0.6*player.itemCooldown/player.inventory[player.slot][0].speed, player.inventory[player.slot][0].size*1.5*0.85, player.inventory[player.slot][0].size*1.5*0.15);
					}
					
					if(player.inventory[player.slot][0].name == "Bow"){
						drawSprite("item", "Bow", canvas.width/2 + Math.sin(swingAngle)*tileSize*0.5 - player.inventory[player.slot][0].size/2, canvas.height/2 + Math.cos(swingAngle)*tileSize*0.5 - player.inventory[player.slot][0].size/2, player.inventory[player.slot][0].size, Math.PI*3/4 - swingAngle, player.inventory[player.slot][0].size/2, player.inventory[player.slot][0].size/2);
					}
					else if(player.inventory[player.slot][0].name != ""){}
					
					
					if(player.inventory[player.slot][0].showHand.main){
						ctx.beginPath();
						ctx.arc(canvas.width/2 + Math.sin(swingAngle - 0.75)*tileSize*0.5, canvas.height/2 + Math.cos(swingAngle - 0.75)*tileSize*0.5, tileSize*0.13, 0, Math.PI*2);
						ctx.fillStyle = "#8a2c00";
						ctx.fill();
						ctx.lineWidth = 2;
						ctx.strokeStyle = "#6e2300";
						ctx.stroke();
						ctx.closePath();
					}
					if(player.inventory[player.slot][0].showHand.off){
						ctx.beginPath();
						ctx.arc(canvas.width/2 + Math.sin(swingAngle + 0.75)*tileSize*0.5, canvas.height/2 + Math.cos(swingAngle + 0.75)*tileSize*0.5, tileSize*0.13, 0, Math.PI*2);
						ctx.fillStyle = "#8a2c00";
						ctx.fill();
						ctx.lineWidth = 2;
						ctx.strokeStyle = "#772600";
						ctx.stroke();
						ctx.closePath();
					}
				}
			}
			function drawHealthBars(){
				for(index1 = 0;index1 < enemyCap;index1++){
					if(enemy[index1].active){
						var healthFraction = enemy[index1].stat.health/enemy[index1].stat.maxLife;
						
						ctx.beginPath();
						ctx.rect(canvas.width/2 + (enemy[index1].pos.x - player.pos.x - enemy[index1].size/2)*tileSize, canvas.height/2 + (enemy[index1].pos.y - player.pos.y + enemy[index1].size*3/4)*tileSize, enemy[index1].size*tileSize, enemy[index1].size/6*tileSize);
						ctx.strokeStyle = healthFraction <= 1/5 ? "DarkRed" : (healthFraction <= 2/5 ? "DarkGoldenrod" : "DarkGreen");
						ctx.fillStyle = healthFraction <= 1/5 ? "FireBrick" : (healthFraction <= 2/5 ? "Goldenrod" : "Green");
						ctx.lineWidth = 5 * enemy[index1].size;
						ctx.stroke();
						ctx.fill();
						ctx.closePath();
						
						ctx.beginPath();
						ctx.rect(canvas.width/2 + (enemy[index1].pos.x - player.pos.x - enemy[index1].size/2)*tileSize, canvas.height/2 + (enemy[index1].pos.y - player.pos.y + enemy[index1].size*3/4)*tileSize, enemy[index1].size*tileSize * healthFraction, enemy[index1].size/6*tileSize);
						ctx.fillStyle = healthFraction <= 1/5 ? "Red" : (healthFraction <= 2/5 ? "Yellow" : "Lime");
						ctx.fill();
						ctx.closePath();
					}
				}
			}
			function drawDust(){}
			
			function drawInventory(){
				for(index1 = 0;index1 < inventorySize.width;index1++){
					for(index2 = 0;index2 < inventorySize.height;index2++){
						ctx.beginPath();
						ctx.rect(index1*70 + 20, index2*70 + 20, 50, 50);
						ctx.strokeStyle = "Goldenrod";
						ctx.globalAlpha = 0.7;
						ctx.lineWidth = 4 * GUIscale;
						ctx.stroke();
						ctx.globalAlpha = 1;
						ctx.closePath();
						
						drawSprite("item", player.inventory[index1][index2].name, index1*70 + 20 + (50 - player.inventory[index1][index2].itemSize)/2, index2*70 + 20 + (50 - player.inventory[index1][index2].itemSize)/2, player.inventory[index1][index2].itemSize);
					}
				}
				
				for(index1 = 0;index1 < equipmentSlots.length;index1++){
					ctx.beginPath();
					ctx.rect(equipmentSlotLocation[index1].x, equipmentSlotLocation[index1].y, 50, 50);
					ctx.strokeStyle = "Gray";
					ctx.globalAlpha = 0.7;
					ctx.lineWidth = 4 * GUIscale;
					ctx.stroke();
					ctx.globalAlpha = 1;
					ctx.closePath();
					
					if(player.equipment[equipmentSlots[index1]].name == "") player.equipment[equipmentSlots[index1]].itemSize = 32;
					drawSprite((player.equipment[equipmentSlots[index1]].name == "") ? "empty":"item", (player.equipment[equipmentSlots[index1]].name == "") ? equipmentSlots[index1] : player.equipment[equipmentSlots[index1]].name, equipmentSlotLocation[index1].x + (50 - player.equipment[equipmentSlots[index1]].itemSize)/2, equipmentSlotLocation[index1].y + (50 - player.equipment[equipmentSlots[index1]].itemSize)/2, player.equipment[equipmentSlots[index1]].itemSize);  //TODO: add textures for empty armor slots
				}
				
				var hearts = Math.ceil(player.stat.maxLife/10);
				for(index1 = 0;index1 < hearts;index1++){
					drawSprite("other", player.stat.health >= (index1 + 1)*10 ? "heart": "heartEmpty", (index1 % 10)*26 + 960 - 12, (Math.floor(index1/10) + 1)*26 - 12, 24);
					if(player.stat.health < (index1 + 1)*10 && player.stat.health >= index1*10){
						ctx.globalAlpha = (player.stat.health - index1*10)/10;
						drawSprite("other", "heart", (index1 % 10)*26 + 960 - 12, (Math.floor(index1/10) + 1)*26 - 12, 24);
						ctx.globalAlpha = 1;
					}
				}
				var stars = Math.ceil(player.stat.maxMana/10);
				for(index1 = 0;index1 < stars;index1++){
					drawSprite("other", player.stat.mana >= (index1 + 1)*10 ? "star": "starEmpty", (index1 %10)*26 + 960 - 12, (Math.floor(hearts/10) + Math.floor(index1/10) + 2)*26 - 12, 24);
					if(player.stat.mana < (index1 + 1)*10 && player.stat.mana >= index1*10){
						ctx.globalAlpha = (player.stat.mana - index1*10)/10;
						drawSprite("other", "star", (index1 %10)*26 + 960 - 12, (Math.floor(hearts/10) + Math.floor(index1/10) + 2)*26 - 12, 24);
						ctx.globalAlpha = 1;
					}
				}
				ctx.beginPath();
				ctx.font = "15px Arial";
				ctx.fillStyle = "White";
				ctx.fillText(Math.ceil(player.stat.health) + "/" + Math.ceil(player.stat.maxLife), Math.min(Math.max(hearts, stars), 10)*26 + 960, 32);
				ctx.fillText(Math.round(player.stat.regen * 26) + "/s", Math.min(Math.max(hearts, stars), 10)*26 + 1040, 32);
				ctx.fillText(Math.ceil(player.stat.mana) + "/" + Math.ceil(player.stat.maxMana), Math.min(Math.max(hearts, stars), 10)*26 + 960, (Math.floor(hearts/10) + 1)*26 + 32);
				ctx.fillText(Math.round(player.stat.manaRegen * 26) + "/s", Math.min(Math.max(hearts, stars), 10)*26 + 1040, (Math.floor(hearts/10) + 1)*26 + 32);
				if(player.stat.armor > 0) ctx.fillText("Armor: " + player.stat.armor, 950, 510);
				//armor sets
				ctx.closePath();
				
				
				
				if(gameState == "playing" && playerView == "inventory" && player.dragItem.name == ""){
					var slotInfo = inSlot(mouse.x, mouse.y);
					if(slotInfo != false){
						drawTooltip(typeof slotInfo == "string" ? player.equipment[slotInfo] : player.inventory[slotInfo.x][slotInfo.y], mouse.x, mouse.y + 35);
					}
				}
				
				drawSprite("item", player.dragItem.name, mouse.x - player.dragItem.itemSize/2, mouse.y - player.dragItem.itemSize/2, player.dragItem.itemSize);
			}
			function drawBigMap(){}
			function drawOverlay(){
				for(index1 = 0;index1 < inventorySize.width;index1++){
					ctx.beginPath();
					ctx.rect(index1*70 + 20, 20, 50, 50);
					ctx.strokeStyle = index1 == player.slot ? "LightBlue" : "Goldenrod";
					ctx.globalAlpha = 0.7;
					ctx.lineWidth = 4 * GUIscale;
					ctx.stroke();
					ctx.globalAlpha = 1;
					ctx.closePath();
					
					drawSprite("item", player.inventory[index1][0].name, index1*70 + 20 + (50 - player.inventory[index1][0].itemSize)/2, 20 + (50 - player.inventory[index1][0].itemSize)/2, player.inventory[index1][0].itemSize);
				}
				var hearts = Math.ceil(player.stat.maxLife/10);
				for(index1 = 0;index1 < hearts;index1++){
					drawSprite("other", player.stat.health >= (index1 + 1)*10 ? "heart": "heartEmpty", (index1 % 10)*26 + 960 - 12, (Math.floor(index1/10) + 1)*26 - 12, 24);
					if(player.stat.health < (index1 + 1)*10 && player.stat.health >= index1*10){
						ctx.globalAlpha = (player.stat.health - index1*10)/10;
						drawSprite("other", "heart", (index1 % 10)*26 + 960 - 12, (Math.floor(index1/10) + 1)*26 - 12, 24);
						ctx.globalAlpha = 1;
					}
				}
				var stars = Math.ceil(player.stat.maxMana/10);
				for(index1 = 0;index1 < stars;index1++){
					drawSprite("other", player.stat.mana >= (index1 + 1)*10 ? "star": "starEmpty", (index1 %10)*26 + 960 - 12, (Math.floor(hearts/10) + Math.floor(index1/10) + 2)*26 - 12, 24);
					if(player.stat.mana < (index1 + 1)*10 && player.stat.mana >= index1*10){
						ctx.globalAlpha = (player.stat.mana - index1*10)/10;
						drawSprite("other", "star", (index1 %10)*26 + 960 - 12, (Math.floor(hearts/10) + Math.floor(index1/10) + 2)*26 - 12, 24);
						ctx.globalAlpha = 1;
					}
				}
			}
			
			function drawSprite(type, name, x, y, scale = 50, r = 0, rx = scale/2, ry = scale/2){
				if(name != ""){
					if(type == "map" && (name == "wall" || name == "fade")){
						ctx.drawImage(sprite[type][name], scale*r, scale*rx, scale, scale, x, y, scale, scale);
					}
					else{
						if(type == "item"){
							if(itemIndex[name] == false || !(itemIndex[name] in sprite.item)) name = 0;
							else name = itemIndex[name];
						}
						if(r == 0) ctx.drawImage(sprite[type][name], x, y, scale, scale);
						else{
							ctx.save();
							ctx.translate(x + rx, y + ry);
							ctx.rotate(r);
							ctx.drawImage(sprite[type][name], rx - scale, ry - scale, scale, scale);
							ctx.restore();
						}
					}
				}
			}
			function drawTooltip(itemRef, x, y){
				if(itemRef.name != ""){
					
					var lines = 0;
					ctx.beginPath();
					ctx.fillStyle = "Black";
					ctx.fillRect(x,y,0,0);
					ctx.font = "15px Arial";
					ctx.fillStyle = "White";
					ctx.fillText(itemRef.name, x, y + lines*22);
					lines++;
					for(index3 = 0;index3 < itemRef.tooltip.length;index3++){
						ctx.fillText(itemRef.tooltip[index3], x, y + lines*22);
						lines++;
					}
					if(itemRef.damage >= 0){
						ctx.fillText(itemRef.damage + (typeof itemRef.damageType == "string" ? " " + itemRef.damageType : "") + " damage", x, y + lines*22);
						lines++;
					}
					if(itemRef.useMana > 0){
						ctx.fillText("Uses " + itemRef.useMana + " mana", x, y + lines*22);
						lines++;
					}
					ctx.closePath();
				}
			}
			
			
			function distance(x,y){
				return Math.sqrt(x*x + y*y);
			}
			function randRange(a, b = 0){
				if(a > b) return randRange(b, a);
				return Math.random()*(b - a) + a;
			}
			
			function wallSprite(UL, U, UR, L, R, DL, D, DR){
				var x = 0;
				var y = 0;
				var d = [UL,U,UR,L,R,DL,D,DR];
				var checkAdj = [[" ","1"," ","1","1"," ","1"," "],[" ","1"," ","1","0"," ","1"," "],[" ","1"," ","0","0"," ","1"," "],[" ","1"," ","0","1"," ","1"," "],[" ","1"," ","1","0"," ","0","1"],[" ","1"," ","0","1","1","0"," "],[" ","0","1","1","0"," ","0","1"],[" ","1"," ","0","0","1","0","1"],["1","0","0","0","0","1","0","1"],["1","0","1","0","0","1","0","0"],["0","0","1","0","0","0","0","1"],["0","0","0","0","0","1","0","1"],
						[" ","1"," ","1","1"," ","0"," "],[" ","1"," ","1","0"," "," ","0"],[" ","1"," ","0","0","0","0","0"],[" ","1"," ","0","1","0","0"," "],[" ","0","1","1","0"," ","1"," "],["1","0"," ","0","1"," ","1"," "],["1","0","1","0","0"," ","1"," "],["1","0"," ","0","1","1","0"," "],["0","0","1","0","0","1","0","1"],["1","0","1","0","0","0","0","1"],["1","0","1","0","0","0","0","0"],["1","0","0","0","0","1","0","0"],
						[" ","0"," ","1","1"," ","0"," "],[" ","0","0","1","0"," ","0","0"],["0","0","0","0","0","0","0","0"],["0","0"," ","0","1","0","0"," "],[" ","0","1","1","0"," ","0","0"],[" ","1"," ","0","0","0","0","1"],[" ","0","0","1","0"," ","0","1"],[" ","1"," ","0","0","1","0","0"],["0","0","0","0","0","0","0","1"],["0","0","0","0","0","1","0","0"],["1","0","0","0","0","0","0","1"],["0","0","1","0","0","1","0","0"],
						[" ","0"," ","1","1"," ","1"," "],[" ","0","0","1","0"," ","1"," "],["0","0","0","0","0"," ","1"," "],["0","0"," ","0","1"," ","1"," "],["1","0","0","0","0"," ","1"," "],["0","0"," ","0","1","1","0"," "],["0","0","1","0","0"," ","1"," "],["1","0"," ","0","1","0","0"," "],["0","0","1","0","0","0","0","0"],["1","0","0","0","0","0","0","0"],["1","0","1","0","0","1","0","1"]];
				for(var index3 = 0;index3 < checkAdj.length;index3++){
					var stop = true;
					for(var index4 = 0;index4 < 8;index4++){
						if(!(checkAdj[index3][index4] == " " || checkAdj[index3][index4] == d[index4] + 0)) stop = false;
					}
					if(stop){
						x = index3 % 12;
						y = Math.floor(index3/12);
					}
				}
				
				return {x:x,y:y};
			}
			function drawFade(x,y){
				var into = [!map[x-1][y-1].discovered, !map[x][y-1].discovered, !map[x+1][y-1].discovered, !map[x-1][y].discovered, !map[x+1][y].discovered, !map[x-1][y+1].discovered, !map[x][y+1].discovered, !map[x+1][y+1].discovered];
				var spritePos = [1,1];
				
				if (into[1] && into[3]) spritePos = [0,0];
				else if (into[1]) spritePos = [1,0];
				else if (into[3]) spritePos = [0,1];
				else if (into[0]) spritePos = [3,0];
				drawSprite("map", "fade", drawPos.x, drawPos.y, 16, spritePos[0], spritePos[1]);
				
				spritePos = [1,1];
				if (into[1] && into[4]) spritePos = [2,0];
				else if (into[1]) spritePos = [1,0];
				else if (into[4]) spritePos = [2,1];
				else if (into[2]) spritePos = [4,0];
				drawSprite("map", "fade", drawPos.x + 32, drawPos.y, 16, spritePos[0], spritePos[1]);
				
				spritePos = [1,1];
				if (into[6] && into[3]) spritePos = [0,2];
				else if (into[6]) spritePos = [1,2];
				else if (into[3]) spritePos = [0,1];
				else if (into[5]) spritePos = [3,1];
				drawSprite("map", "fade", drawPos.x, drawPos.y + 32, 16, spritePos[0], spritePos[1]);
				
				spritePos = [1,1];
				if (into[6] && into[4]) spritePos = [2,2];
				else if (into[6]) spritePos = [1,2];
				else if (into[4]) spritePos = [2,1];
				else if (into[7]) spritePos = [4,1];
				drawSprite("map", "fade", drawPos.x + 32, drawPos.y + 32, 16, spritePos[0], spritePos[1]);
				
				spritePos = [1,1];
				if (into[1]) spritePos = [1,0];
				drawSprite("map", "fade", drawPos.x + 16, drawPos.y, 16, spritePos[0], spritePos[1]);
				
				spritePos = [1,1];
				if (into[3]) spritePos = [0,1];
				drawSprite("map", "fade", drawPos.x, drawPos.y + 16, 16, spritePos[0], spritePos[1]);
				
				spritePos = [1,1];
				if (into[6]) spritePos = [1,2];
				drawSprite("map", "fade", drawPos.x + 16, drawPos.y + 32, 16, spritePos[0], spritePos[1]);
				
				spritePos = [1,1];
				if (into[4]) spritePos = [2,1];
				drawSprite("map", "fade", drawPos.x + 32, drawPos.y + 16, 16, spritePos[0], spritePos[1]);
			}
			
			function adjustMapEdge(){
				var newMap = {left:Math.min(Math.floor(player.pos.x - loadRadius), mapEdge.left), right:Math.max(Math.ceil(player.pos.x + loadRadius), mapEdge.right), top:Math.min(Math.floor(player.pos.y - loadRadius), mapEdge.top), bottom:Math.max(Math.ceil(player.pos.y + loadRadius), mapEdge.bottom)};
				if(newMap.left != mapEdge.left || newMap.right != mapEdge.right || newMap.top != mapEdge.top || newMap.bottom != mapEdge.bottom){
					for(index1 = newMap.left;index1 < newMap.right;index1++){
						if(index1 < mapEdge.left || index1 >= mapEdge.right){
							map[index1] = [];
						}
						for(index2 = newMap.top;index2 < newMap.bottom;index2++){
							if(index1 < mapEdge.left || index1 >= mapEdge.right || index2 < mapEdge.top || index2 >= mapEdge.bottom){
								map[index1][index2] = {
									discovered:false,
									wall:true,
									object:"",
									open:false,
									rotation:0
								};
							}
						}
					}
					setProperties(mapEdge, newMap);
				}
			}
			
			
			function isEquivalent(a, b) {
				var aProps = Object.getOwnPropertyNames(a);
				var bProps = Object.getOwnPropertyNames(b);
				if (aProps.length != bProps.length) {
					return false;
				}
				
				for (var i = 0; i < aProps.length; i++) {
					var propName = aProps[i];
					if (a[propName] !== b[propName]) {
						return false;
					}
				}
				return true;
			}
			function setProperties(a, b, replace = false){
				var bProps = Object.getOwnPropertyNames(b);
				if(replace){
					var aProps = Object.getOwnPropertyNames(a);
					for (var i = 0; i < aProps.length; i++){
						delete a[aProps[i]];
					}
				}
				for (var i = 0; i < bProps.length; i++){
					a[bProps[i]] = b[bProps[i]];
				}
			}
			
			
			document.addEventListener("keydown", keyDownHandler, false);
			document.addEventListener("keyup", keyUpHandler, false);
			document.addEventListener("keypress", keyPressHandler, false);
			function keyDownHandler(e) {
				for(index1 = 0;index1 < 4;index1++){
					if(e.key == controls[index1]) player.key[direction[index1]] = true;
				}
				if(e.key == controls[6]){
					
				}
			}
			function keyUpHandler(e) {
				for(index1 = 0;index1 < controls.length;index1++){
					if(e.key == controls[index1]) player.key[direction[index1]] = false;
				}
			}
			function keyPressHandler(e) {
				if(e.key == controls[4]){
					var x, y;
					var opened = false;
					for(index1 = 0;index1 < 4;index1++){
						x = Math.floor(player.pos.x + (index1 < 2 ? player.size/2 : 0)*(index1 == 0 ? -1 : 1));
						y = Math.floor(player.pos.y + (index1 > 1 ? player.size/2 : 0)*(index1 == 2 ? -1 : 1));
						if(map[x][y].object == "door"){
							if(!map[x][y].open && map[x - 1][y].discovered + map[x + 1][y].discovered + map[x][y - 1].discovered + map[x][y + 1].discovered == 3){ //change to 1 later
								buildRoom(x, y);
							}
							if(!opened){
								map[x][y].open = !map[x][y].open;
								opened = true;
							}
						}
					}
				}
				if(e.key == controls[5]){
					if(playerView == "game") playerView = "inventory";
					else if(playerView == "inventory") playerView = "game";
				}
				if(playerView == "game" && player.itemCooldown == 0 && e.key > 0 && e.key <= inventorySize.width) player.slot = e.key - 1;
			}
			
			
			
			//==========================================================================================================================================================================================================
			
			
			makeRoom(startRoom, Math.floor(player.pos.x) - 3, Math.floor(player.pos.y) - 5);
			roomShape(Math.floor(player.pos.x), Math.floor(player.pos.y) - 6, 14);
			setProperties(player.inventory[0][0], item[1]);
			setProperties(player.inventory[1][0], item[2]);
			setProperties(player.inventory[2][0], item[3]);
			setProperties(player.inventory[3][0], item[4]);
			setProperties(player.inventory[4][0], item[5]);
			setProperties(player.inventory[5][0], item[6]);
			setProperties(player.inventory[6][0], item[20]);
			setProperties(player.inventory[0][1], item[10]);
			setProperties(player.inventory[1][1], item[11]);
			setProperties(player.inventory[2][1], item[13]);
			setProperties(player.inventory[3][1], item[8]);
			
			function draw() {
				
				ctx.clearRect(0,0,canvas.width,canvas.height);
				
				
				
				if(gameState == "playing"){
					adjustMapEdge();
					updatePlayerStats();
					if(playerView == "game"){
						movePlayer();
						moveEnemies();
						moveProjectiles();
						moveDust();
						
						killStuff();
						
						drawMap();
						drawHealthBars();
						drawProjectiles();
						drawWeapons();
						drawDust();
						drawEnemies();
						drawPlayer();
						
						drawOverlay();
					}
					if(playerView == "inventory"){
						drawMap();
						drawHealthBars();
						drawProjectiles();
						drawWeapons();
						drawDust();
						drawEnemies();
						drawPlayer();
						
						ctx.beginPath();
						ctx.globalAlpha = 0.9;
						ctx.fillStyle = "Black";
						ctx.fillRect(0, 0, canvas.width, canvas.height);
						ctx.globalAlpha = 1;
						ctx.closePath();
						
						drawInventory();
					}
					if(playerView == "map"){
						drawBigMap();
					}
				}
				
				setTimeout(draw, 20);
			}
			draw();
        		
   		 </SCRIPT>
	</body>
</html>
