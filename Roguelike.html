<!DOCTYPE html>
<html>

<head>

	<style>
		* {
			padding: 0;
			margin: 0;
		}
		
		canvas {
			background: black;
			display: block;
			margin: 0 auto;
		}
	</style>

<title>Dungeon Crawler</title>
</head>

<body>

	<canvas id="myCanvas" width="1350" height="640"></canvas>

	<body style="background-color:black;">

		<SCRIPT LANGUAGE="JavaScript">
			
			
			var canvas = document.getElementById("myCanvas");
			var ctx = canvas.getContext("2d");
			
			var map = [[{}]];
			var mapEdge = {top:900, bottom:1100, left:900, right:1100};
			var tileSize = 35;
			
			var gameState = "playing";  //playing, dead, choosing
			var playerView = "game";  //game, inventory, map
			
			var inventorySize = {width:7, height:4};
			
			var enemy = [{}];
			var projectile = {player:[{}], enemy:[{}]};
			
			
			
			var player = {
				pos:{
					x:1000.5,
					y:1000.5
				},
				speed:{
					x:0,
					y:0
				},
				size:0.8,
				dead:false,
				inventory:{
					hotbar:[0],
					storage:[0],
					equipment:{head:null, body:null, legs:null, feet:null, arm1:null, arm2:null, hands:null, neck:null}
				},
				slot:0,
				itemCooldown:0,
				stat:{
					health:100,
					mana:0,
					maxLife:100,
					maxMana:10,
					speed:0.2,
					acceleration:0.03,
					regen:0.1,
					manaRegen:0.1,
					armor:0,
					damageBonus:0
				},
				key:{up:false,down:false,left:false,right:false}
			};
			
			
			var index1;
			var index2;
			
			var enemyCap = 100;
			var projectileCap = 1000;
			var projOwner = ["player","enemy"];
			
			for(index1 = mapEdge.left;index1 <= mapEdge.right;index1++){
				map[index1] = [];
				for(index2 = mapEdge.top;index2 <= mapEdge.bottom;index2++){
					map[index1][index2] = {
						discovered:false,
						wall:true,
						object:"", //door, chest
						open:false,
						rotation:0
					};
				}
			}
			
			for(index1 = 0;index1 < enemyCap;index1++){
				enemy[index1] = {
					pos:{
						x:0,
						y:0
					},
					speed:{
						x:0,
						y:0
					},
					type:"",
					size:0.8,
					target:null,
					dead:true,
					cooldown:0,
					stat:{
						health:100,
						mana:0,
						maxLife:100,
						maxMana:10,
						speed:1,
						regen:0.1,
						manaRegen:0.1,
						armor:0
					}
				}
			}
			
			for(index1 = 0;index1 < 2;index1++){
				for(index2 = 0;index2 < projectileCap;index2++){
					projectile[projOwner[index1]][index2] = {
						pos:{
							x:0,
							y:0
						},
						speed:{
							x:0,
							y:0
						},
						type:"",
						dead:0,
						size:0,
						damage:0
					}
				}
			}
			
			var controls = ["w","s","a","d"];
			var direction = ["up","down","left","right"];
			var edgeDirection = ["top","bottom","left","right"];
			var item = [
				{
					name:"Base Item",
					type:["swing","stab","shoot"],
					damage:0,
					speed:0,
					autoUse:false,
					ammoType:["arrows","knives"],
					useAmmo:0,
					useMana:0
				},
				{
					name:"Wooden Sword",
					type:"swing",
					damage:3,
					speed:15,
					autoUse:false
				},
				{
					name:"Knives",
					type:"stab",
					damage:2,
					speed:7,
					autoUse:true
				},
				{
					name:"Laser Gun",
					type:"shoot",
					damage:10,
					speed:10,
					autoUse:true,
					useMana:3
				},
				{
					name:"Fire Staff",
					type:"shoot",
					damage:30,
					speed:30,
					autoUse:false,
					useMana:12
				}
			];
			var startRoom = [
				["w","w","w","d","w","w","w"],
				["w"," "," "," "," "," ","w"],
				["w"," "," "," "," "," ","w"],
				["w"," "," ","c"," "," ","w"],
				["w"," "," "," "," "," ","w"],
				["w"," "," "," "," "," ","w"],
				["w","w","w","w","w","w","w"]
			];  //Wall, Door, Chest, Ignore
			
			
			
			
			function getMousePos(canvas, evt) {
				var rect = canvas.getBoundingClientRect();
				return {
					x: Math.floor(evt.clientX - rect.left),
					y: Math.floor(evt.clientY - rect.top)
				};
			}
			document.addEventListener("click", onClick, false);
			function onClick(evt){
				if(event.button == 0){
					var mouse = getMousePos(canvas, evt);
					
				}
			}

			window.oncontextmenu = function(evt){
				var mouse = getMousePos(canvas, evt);
				
				return false;
			}
			
			
			
			
			
			
			
			function buildRoom(x, y, size = Math.floor(Math.random()*8 + 6), doors = 2, chests = 0, enemies = []){  //random generation
				if(map[x][y].object != "door") return false;
				
				var index3, index4;
				
				var entrance = "";
				var roomDirection = "";
				if(!map[x - 1][y].wall){entrance = "left"; roomDirection = "right";}
				if(!map[x + 1][y].wall){entrance = "right"; roomDirection = "left";}
				if(!map[x][y - 1].wall){entrance = "top"; roomDirection = "bottom";}
				if(!map[x][y + 1].wall){entrance = "bottom"; roomDirection = "top";}
				if(roomDirection == "") return false;
				
				var doorSide = {top:false,bottom:false,left:false,right:false};
				doorSide[roomDirection] = true;
				
				var extend = {};
				for(index3 = 0;index3 < 4;index3++){
					extend[edgeDirection[index3]] = entrance == edgeDirection[index3] ? 0 : Math.floor((Math.random()*(size - 6) + 6)/(roomDirection == edgeDirection[index3] ? 1 : 2));
				}
				var boundaries = {};
				for(index3 = 0;index3 < 4;index3++){
					boundaries[edgeDirection[index3]] = (index3 < 2 ? y:x) + extend[edgeDirection[index3]]*(index3 % 2 == 0 ? -1:1);
				}
				for(index3 = boundaries.left + 1;index3 < boundaries.right;index3++){
					for(index4 = boundaries.top + 1;index4 < boundaries.bottom;index4++){
						map[index3][index4].wall = false;
					}
				}
				
				var doorCount = 1;
				while(doorCount < doors){
					var rand = {x:Math.floor(Math.random()*(boundaries.bottom - boundaries.top + 1) + boundaries.top), y:Math.floor(Math.random()*(boundaries.right - boundaries.left + 1) + boundaries.left)};
					if(map[rand.x][rand.y].wall && map[rand.x - 1][rand.y].wall + map[rand.x + 1][rand.y].wall + map[rand.x][rand.y - 1].wall + map[rand.x][rand.y + 1].wall == 3){
						if(!(map[rand.x + 1][rand.y].wall || doorSide.left)){
							map[rand.x][rand.y].wall = false;
							map[rand.x][rand.y].object = "door";
							map[rand.x][rand.y].rotation = 1;
							doorCount++;
						}
					}
				}
				
				for(index3 = boundaries.left + 1;index3 < boundaries.right;index3++){
					for(index4 = boundaries.top + 1;index4 < boundaries.bottom;index4++){
						if(!map[index3][index4].wall) map[index3][index4].discovered = true;
					}
				}
			}
			
			function makeRoom(plan, x, y){  //plan is a 2D array
				for(var index4 = 0;index4 < plan.length;index4++){
					for(var index3 = 0;index3 < plan[index4].length;index3++){
						if(!(plan[index4][index3] == "w" || plan[index4][index3] == "i")){
							map[x + index3][y + index4].wall = false;
							map[x + index3][y + index4].discovered = true;
						}
						if(plan[index4][index3] == "d"){
							map[x + index3][y + index4].object = "door";
							map[x + index3][y + index4].open = false;
							
						}
						if(plan[index4][index3] == "c"){
							map[x + index3][y + index4].object = "chest";
							map[x + index3][y + index4].open = false;
						}
					}
				}
			}
			
			
			function movePlayer(){
				if(player.key.left ) player.speed.x -= player.stat.acceleration;
				if(player.key.right) player.speed.x += player.stat.acceleration;
				if(player.key.up   ) player.speed.y -= player.stat.acceleration;
				if(player.key.down ) player.speed.y += player.stat.acceleration;
				
				if(!(player.key.left || player.key.right || player.speed.x == 0)) player.speed.x += player.stat.acceleration * (player.speed.x > 0 ? -1 : 1);
				if(!(player.key.up   || player.key.down  || player.speed.y == 0)) player.speed.y += player.stat.acceleration * (player.speed.y > 0 ? -1 : 1);
				
				if(Math.abs(player.speed.x) < player.stat.acceleration) player.speed.x = 0;
				if(Math.abs(player.speed.y) < player.stat.acceleration) player.speed.y = 0;
				
				player.speed.x = Math.max(Math.min(player.speed.x, player.stat.speed), -player.stat.speed);
				player.speed.y = Math.max(Math.min(player.speed.y, player.stat.speed), -player.stat.speed);
				player.pos.x += player.speed.x;
				player.pos.y += player.speed.y;
				
				
				if(!map[Math.floor(player.pos.x)][Math.floor(player.pos.y)].wall){
					//wall side
					var bounce = wallCollisions(player.pos.x, player.pos.y, player.size/2);
					player.pos.x = bounce.x;
					player.pos.y = bounce.y;
					if(bounce.left || bounce.right) player.speed.x = 0;
					if(bounce.up   || bounce.down ) player.speed.y = 0;
					//door
					if(map[Math.floor(player.pos.x - player.size/2)][Math.floor(player.pos.y)].object == "door" &&
					  !map[Math.floor(player.pos.x - player.size/2)][Math.floor(player.pos.y)].open &&
					   map[Math.floor(player.pos.x - player.size/2)][Math.floor(player.pos.y)].rotation % 2 == 1 &&
					  (player.pos.x - player.size/2) % 1 < 3/5){
						player.pos.x = Math.floor(player.pos.x - player.size/2) + 3/5 + player.size/2;
					}
					if(map[Math.floor(player.pos.x + player.size/2)][Math.floor(player.pos.y)].object == "door" &&
					  !map[Math.floor(player.pos.x + player.size/2)][Math.floor(player.pos.y)].open &&
					   map[Math.floor(player.pos.x + player.size/2)][Math.floor(player.pos.y)].rotation % 2 == 1 &&
					  (player.pos.x + player.size/2) % 1 > 2/5){
						player.pos.x = Math.floor(player.pos.x + player.size/2) + 2/5 - player.size/2 - 0.0001;
					}
					if(map[Math.floor(player.pos.x)][Math.floor(player.pos.y - player.size/2)].object == "door" &&
					  !map[Math.floor(player.pos.x)][Math.floor(player.pos.y - player.size/2)].open &&
					   map[Math.floor(player.pos.x)][Math.floor(player.pos.y - player.size/2)].rotation % 2 == 0 &&
					  (player.pos.y - player.size/2) % 1 < 3/5){
						player.pos.y = Math.floor(player.pos.y - player.size/2) + 3/5 + player.size/2;
					}
					if(map[Math.floor(player.pos.x)][Math.floor(player.pos.y + player.size/2)].object == "door" &&
					  !map[Math.floor(player.pos.x)][Math.floor(player.pos.y + player.size/2)].open &&
					   map[Math.floor(player.pos.x)][Math.floor(player.pos.y + player.size/2)].rotation % 2 == 0 &&
					  (player.pos.y + player.size/2) % 1 > 2/5){
						player.pos.y = Math.floor(player.pos.y + player.size/2) + 2/5 - player.size/2 - 0.0001;
					}
				}
			}
			function moveEnemies(){}
			function moveProjectiles(){}
			
			function wallCollisions(x, y, size, disable = false){
				var collisions = {x:x, y:y, up:false, down:false, left:false, right:false, upLeft:false, upRight:false, downLeft:false, downRight:false};
				if(!map[Math.floor(x)][Math.floor(y)].wall){
					if(map[Math.floor(x - size)][Math.floor(y)].wall){
						x = Math.floor(x) + size;
						collisions.left = true;
					}
					if(map[Math.floor(x + size)][Math.floor(y)].wall){
						x = Math.floor(x) - size + 0.9999;
						collisions.right = true;
					}
					if(map[Math.floor(x)][Math.floor(y - size)].wall){
						y = Math.floor(y) + size;
						collisions.up = true;
					}
					if(map[Math.floor(x)][Math.floor(y + size)].wall){
						y = Math.floor(y) - size + 0.9999;
						collisions.down = true;
					}
					if(map[Math.floor(x - size)][Math.floor(y - size)].wall){
						var cornerDistance = distance(x - Math.floor(x), y - Math.floor(y));
						if(cornerDistance < size){
							x = Math.floor(x) + ((x - Math.floor(x)) * (size)/cornerDistance);
							y = Math.floor(y) + ((y - Math.floor(y)) * (size)/cornerDistance);
							collisions.upLeft = true;
						}
					}
					if(map[Math.floor(x + size)][Math.floor(y - size)].wall){
						var cornerDistance = distance(x - Math.ceil(x), y - Math.floor(y));
						if(cornerDistance < size){
							x = Math.ceil (x) + ((x - Math.ceil (x)) * (size)/cornerDistance);
							y = Math.floor(y) + ((y - Math.floor(y)) * (size)/cornerDistance);
							collisions.upRight = true;
						}
					}
					if(map[Math.floor(x - size)][Math.floor(y + size)].wall){
						var cornerDistance = distance(x - Math.floor(x), y - Math.ceil (y));
						if(cornerDistance < size){
							x = Math.floor(x) + ((x - Math.floor(x)) * (size)/cornerDistance);
							y = Math.ceil (y) + ((y - Math.ceil (y)) * (size)/cornerDistance);
							collisions.downLeft = true;
						}
					}
					if(map[Math.floor(x + size)][Math.floor(y + size)].wall){
						var cornerDistance = distance(x - Math.ceil (x), y - Math.ceil (y));
						if(cornerDistance < size){
							x = Math.ceil (x) + ((x - Math.ceil (x)) * (size)/cornerDistance);
							y = Math.ceil (y) + ((y - Math.ceil (y)) * (size)/cornerDistance);
							collisions.downRight = true;
						}
					}
					
					collisions.x = x;
					collisions.y = y;
				}
				
				return collisions;
			}
			
			
			
			function drawMap(){
				for(index1 = Math.max(mapEdge.left, Math.floor(player.pos.x - (canvas.width/2)/tileSize));index1 <= Math.min(mapEdge.right, Math.ceil(player.pos.x + (canvas.width/2)/tileSize));index1++){
					for(index2 = Math.max(mapEdge.top, Math.floor(player.pos.y - (canvas.height/2)/tileSize));index2 <= Math.min(mapEdge.bottom, Math.ceil(player.pos.y + (canvas.height/2)/tileSize));index2++){
						if(map[index1][index2].discovered){
							var drawPos = {x:canvas.width/2 + Math.floor((index1 - player.pos.x)*tileSize), y:canvas.height/2 + Math.floor((index2 - player.pos.y)*tileSize)};
							if(!map[index1][index2].wall){
								ctx.beginPath();
								ctx.fillStyle = "Gray";
								ctx.fillRect(drawPos.x, drawPos.y, tileSize, tileSize);
								ctx.closePath();
							}
							if(map[index1][index2].object == "door"){
								if(map[index1][index2].open){
									if(map[index1][index2].rotation == 0){
										ctx.beginPath();
										ctx.fillStyle = "#772600";
										ctx.fillRect(drawPos.x, drawPos.y, tileSize*1/5, tileSize*3/5);
										ctx.fillRect(drawPos.x + tileSize*4/5, drawPos.y, tileSize*1/5, tileSize*3/5);
										ctx.closePath();
									}
									else{
										
									}
								}
								else{
									if(map[index1][index2].rotation % 2 == 0){
										if(!map[index1][index2 - 1].discovered){
											ctx.beginPath();
											ctx.fillStyle = "Black";
											ctx.fillRect(drawPos.x, drawPos.y, tileSize, tileSize/2);
											ctx.closePath();
										}
										if(!map[index1][index2 + 1].discovered){
											ctx.beginPath();
											ctx.fillStyle = "Black";
											ctx.fillRect(drawPos.x, drawPos.y + tileSize/2, tileSize, tileSize/2);
											ctx.closePath();
										}
										ctx.beginPath();
										ctx.fillStyle = "#772600";
										ctx.fillRect(drawPos.x, drawPos.y + tileSize*2/5, tileSize, tileSize*1/5);
										ctx.closePath();
									}
									else{
										if(!map[index1 - 1][index2].discovered){
											ctx.beginPath();
											ctx.fillStyle = "Black";
											ctx.fillRect(drawPos.x, drawPos.y, tileSize/2, tileSize);
											ctx.closePath();
										}
										if(!map[index1 + 1][index2].discovered){
											ctx.beginPath();
											ctx.fillStyle = "Black";
											ctx.fillRect(drawPos.x + tileSize/2, drawPos.y, tileSize/2, tileSize);
											ctx.closePath();
										}
										ctx.beginPath();
										ctx.fillStyle = "#772600";
										ctx.fillRect(drawPos.x + tileSize*2/5, drawPos.y, tileSize*1/5, tileSize);
										ctx.closePath();
									}
								}
							}
						}
					}
				}
			}
			function drawPlayer(){
				ctx.beginPath();
				ctx.arc(canvas.width/2, canvas.height/2, tileSize * player.size/2, 0, Math.PI*2);
				ctx.fillStyle = "#772600";
				ctx.fill();
				ctx.closePath();
			}
			function drawProjectiles(){}
			
			function drawInventory(){}
			function drawBigMap(){}
			
			
			
			function distance(x,y){
				return Math.sqrt(x*x + y*y);
			}
			
			document.addEventListener("keydown", keyDownHandler, false);
			document.addEventListener("keyup", keyUpHandler, false);
			document.addEventListener("keypress", keyPressHandler, false);
			function keyDownHandler(e) {
				for(index1 = 0;index1 < controls.length;index1++){
					if(e.key == controls[index1]) player.key[direction[index1]] = true;
				}
			}
			function keyUpHandler(e) {
				for(index1 = 0;index1 < controls.length;index1++){
					if(e.key == controls[index1]) player.key[direction[index1]] = false;
				}
			}
			function keyPressHandler(e) {
				if(e.key == "e"){
					var x, y;
					var opened = false;
					for(index1 = 0;index1 < 4;index1++){
						x = Math.floor(player.pos.x + (index1 < 2 ? player.size/2 : 0)*(index1 == 0 ? -1 : 1));
						y = Math.floor(player.pos.y + (index1 > 1 ? player.size/2 : 0)*(index1 == 2 ? -1 : 1));
						if(map[x][y].object == "door"){
							if(!map[x][y].open && map[x - 1][y].wall + map[x + 1][y].wall + map[x][y - 1].wall + map[x][y + 1].wall == 3){ //change to 1 later
								buildRoom(x, y);
							}
							if(!opened){
								map[x][y].open = !map[x][y].open;
								opened = true;
							}
						}
					}
				}
			}
			
			
			
			//==========================================================================================================================================================================================================
			
			
			makeRoom(startRoom, Math.floor(player.pos.x) - 3, Math.floor(player.pos.y) - 5);
			
			function draw() {
				
				ctx.clearRect(0,0,canvas.width,canvas.height);
				
				
				
				if(gameState == "playing"){
					if(playerView == "game"){
						movePlayer();
						
						drawMap();
						drawPlayer();
					}
				}
				
				
				
				
				setTimeout(draw, 20);
			}
			draw();
        		
   		 </SCRIPT>
	</body>
</html>
